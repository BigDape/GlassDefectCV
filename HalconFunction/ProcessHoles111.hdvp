<?xml version="1.0" encoding="UTF-8"?>
<hdevelop file_version="1.2" halcon_version="22.05.0.0">
<procedure name="ProcessHoles">
<interface>
<io>
<par name="Image1" base_type="iconic" dimension="0"/>
<par name="Image2" base_type="iconic" dimension="0"/>
<par name="Image3" base_type="iconic" dimension="0"/>
<par name="Image4" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="OutLineImage" base_type="iconic" dimension="0"/>
<par name="HolesImage" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="DetectDict" base_type="ctrl" dimension="0"/>
<par name="Cam1pixs" base_type="ctrl" dimension="0"/>
<par name="Cam1Width" base_type="ctrl" dimension="0"/>
<par name="Tile2Column1" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="ResultDictHoles" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>try</l>
<l>* set_system ('parallelize_operators', 'true')</l>
<l>dev_update_off ()</l>
<l>* dev_update_time ('off')</l>
<l>* dev_update_pc ('off')</l>
<l>* dev_update_var ('off')</l>
<l>dev_update_window ('off')</l>
<l>set_system ('clip_region', 'false')</l>
<c>**********************初始化输出*****************************</c>
<l>set_system ('clip_region', 'false')</l>
<l>gen_empty_obj (SiYin)</l>
<l>gen_empty_obj (SiYinDefect)</l>
<l>Phi11X:=0</l>
<l>Phi12X:=0</l>
<l>Abs:=0</l>
<l>     typeSiYin:=[]</l>
<l>     SiYinOK:=[]</l>
<l>     SiYinDistanceHorizontal:=[]</l>
<l>     SiYinDistanceVertical:=[]</l>
<c> </c>
<l>siyinWidth:=[]</l>
<l>siyinHeight:=[]</l>
<l>pingjieposition:=0 </l>
<l>NumberH:=0</l>
<l>NumberMJ:=0</l>
<l>dev_set_draw ('fill')</l>
<l>GlassOK:=[]</l>
<l>QKOK:=[]</l>
<l>MJOK:=[]</l>
<l>QKWidth:=[]</l>
<l>QKHeight:=[]</l>
<l>siyinRow:=[]</l>
<l>siyinColumn:=[]</l>
<c></c>
<l>Type:=[]</l>
<l>QKOK:=[]</l>
<l>DistanceHorizontal:=[]</l>
<l>DistanceVertical:=[]</l>
<c>            </c>
<c></c>
<c></c>
<l>gen_empty_obj (HolesImage)</l>
<l>gen_empty_obj (QKImage)</l>
<l>gen_empty_obj (TransformedRegion)</l>
<l>gen_empty_obj (OutLineImage)</l>
<l>gen_empty_obj(LinesVContours)</l>
<l>gen_empty_obj(LinesHContours)</l>
<l>gen_empty_obj(SelectedRegionsHoles)</l>
<l>gen_empty_obj(SelectedRegionsMJ)</l>
<l>gen_empty_obj(ObjectsConcatQK)</l>
<l>gen_empty_obj (siyinrImage)</l>
<l>gen_empty_obj (menjiarImage)</l>
<l>gen_empty_obj (rImage)</l>
<c></c>
<c></c>
<c></c>
<l>get_image_size (Image3, Width_Image, Height_Image)</l>
<l>pixValueBottom:=0.102796558</l>
<c></c>
<c></c>
<c></c>
<l>Cam1pixSetValue:=0</l>
<l>Cam2pixSetValue:=0</l>
<c>*0.10226235</c>
<l>get_dict_tuple (DetectDict,'尺寸测量', MersureDict)</l>
<l>get_dict_tuple (MersureDict,'相机1像素0精度', Cam1pixSetValue)</l>
<l>get_dict_tuple (MersureDict,'相机2与相机1精度比值', CamPixRatio)</l>
<l>get_dict_tuple (MersureDict,'相机1像素k值', KxCam1)</l>
<l>get_dict_tuple (MersureDict,'相机2像素k值', KxCam2)</l>
<c></c>
<l>pixValueC1:=(2*Cam1pixSetValue+KxCam1*Cam1Width)/2.000000</l>
<l>pixValueC2:=(2*Cam1pixSetValue*CamPixRatio+KxCam2*Cam1Width)/2.000000</l>
<l>pixValueSetV:=(pixValueC1+pixValueC2)/2.000000</l>
<l>Cam2pixSetValue:=CamPixRatio*Cam1pixSetValue</l>
<c></c>
<l>get_dict_tuple (DetectDict,'缺陷检测', detectDict)</l>
<l>get_dict_tuple (detectDict,'玻璃厚度' , thickness)</l>
<l>get_dict_tuple (detectDict,'丝印离辊道距离' , siyindistance)</l>
<c></c>
<l>get_dict_tuple (DetectDict,'编码器参数', CodeDict)</l>
<l>get_dict_tuple (CodeDict,'编码器转数', CodeNumPr)</l>
<l>get_dict_tuple (CodeDict,'辊道周长', RollerPer)</l>
<l>get_dict_tuple (CodeDict,'每行对应的编码计数', CodeCountPerLine)</l>
<c></c>
<l>Cam1pixSetValue:=Cam1pixSetValue*6508/(6508+(16*thickness)/5.000000)</l>
<l>Cam2pixSetValue:=Cam2pixSetValue*6508/(6508+(16*thickness)/5.000000)</l>
<c></c>
<l>pixValue:=pixValueSetV*6508/(6508+(16*thickness)/5.000000)</l>
<l>pixValuesiyin:=pixValueSetV*6508/(6508+(16*siyindistance)/5.000000)</l>
<c></c>
<l>DistanceHorizontal:=[]</l>
<l>DistanceVertical:=[]</l>
<l>HolesHeight:=[]</l>
<l>HolesWidth:=[]</l>
<l>GlassWidth:=[]</l>
<l>GlassHeight:=[]</l>
<c></c>
<c></c>
<l>threshold (Image2, RegionFL, 15, 255)</l>
<l>opening_rectangle1 (RegionFL, RegionOpeningFL, 1, 20)</l>
<c></c>
<l>connection (RegionOpeningFL, ConnectedRegionsFL)</l>
<l>select_shape_std (ConnectedRegionsFL, SelectedRegionsFL, 'max_area', 70)</l>
<l>closing_rectangle1 (SelectedRegionsFL, SelectedRegionsFL, 1, 100)</l>
<c></c>
<c></c>
<l>region_features (SelectedRegionsFL, 'width', RegionsWidth)</l>
<l>erosion_circle (SelectedRegionsFL, RegionErosionFL, 20.5)</l>
<l>difference (SelectedRegionsFL, RegionErosionFL, RegionDifferenceFL)</l>
<l>opening_rectangle1 (RegionDifferenceFL, RegionOpening1FL, 30, 1)</l>
<l>connection (RegionOpening1FL, ConnectedRegions2FL)</l>
<l>select_shape (ConnectedRegions2FL, SelectedRegions1FL, 'width', 'and', 0.8*RegionsWidth, 2*RegionsWidth)</l>
<l>dilation_circle (SelectedRegions1FL, RegionDilationFL, 100.5)</l>
<c></c>
<c></c>
<c></c>
<l>threshold (Image1, RegionTL, 0, 20)</l>
<l>intersection (RegionDilationFL, RegionTL, RegionIntersectionFT)</l>
<l>connection (RegionIntersectionFT, ConnectedRegionsTL)</l>
<l>select_shape (ConnectedRegionsTL, SelectedRegionsTL, 'width', 'and', 0.8*RegionsWidth, 2*RegionsWidth)</l>
<l>union2 (SelectedRegionsTL, SelectedRegionsFL, RegionUnionFT1)</l>
<l>union1 (RegionUnionFT1, RegionUnionFT1)</l>
<c></c>
<c>****************************** 测试**************************</c>
<l>height_width_ratio (RegionUnionFT1, Height1, Width1, Ratio1)</l>
<l>region_features (RegionUnionFT1, 'column1', ValueColumn1)</l>
<l>region_features (RegionUnionFT1, 'row2', ValueRow2)</l>
<l>numW:=Width1/10</l>
<l>height_Region:=[]</l>
<l>for i := 1 to 9 by 1</l>
<l>    gen_region_line (RegionLinesH1, 0, numW*i+ValueColumn1, ValueRow2+1000, numW*i+ValueColumn1)</l>
<l>    intersection (RegionLinesH1, RegionUnionFT1, RegionIntersectionH1)</l>
<l>    region_features (RegionIntersectionH1, 'area', Value1)</l>
<l>    height_Region:=[height_Region,Value1]</l>
<c>    </c>
<l>endfor</l>
<c></c>
<c></c>
<c>****************************** 测试**************************</c>
<c></c>
<l>closing_circle (RegionUnionFT1, RegionClosingFT, 13.5)</l>
<l>opening_rectangle1 (RegionClosingFT, RegionUnionFT2, 1, 100)</l>
<c></c>
<c>***玻璃轮廓填充************</c>
<l>closing_rectangle1 (RegionUnionFT2, RegionClosingFT2, 1, 1000)</l>
<l>closing_rectangle1 (RegionClosingFT2, RegionFilled, 1000, 1)</l>
<l>erosion_circle (RegionFilled, RegionFilled, 100.5)</l>
<l>reduce_domain (Image2, RegionFilled, ImageReduced2)</l>
<c></c>
<c></c>
<c></c>
<l>threshold (ImageReduced2, RegionH, 0, 60)</l>
<l>connection (RegionH, ConnectedRegionsH)</l>
<l>select_shape (ConnectedRegionsH, SelectedRegionsH, 'area', 'and', 5000, 999999)</l>
<l>select_shape (SelectedRegionsH, SelectedRegionsH, 'roundness', 'and', 0.8, 1)</l>
<l>fill_up (SelectedRegionsH, RegionFillUpH)</l>
<l>opening_circle (RegionFillUpH, RegionOpeningH, 1.5)</l>
<l>union1 (RegionOpeningH, RegionUnionH)</l>
<l>difference (RegionUnionFT2, RegionUnionH, RegionUnionFT)</l>
<c></c>
<l>PixelAccuracyX:=pixValue</l>
<l>pixYValueCal:=(RollerPer/1000.000000)/((CodeNumPr*4)/4.000000)</l>
<c></c>
<l>get_dict_tuple (MersureDict,'Y方向精度K', Ky)</l>
<l>get_dict_tuple (MersureDict,'Y方向精度B', By)</l>
<c></c>
<l>PixelAccuracyY:=Ky*pixYValueCal</l>
<c>*0.10902//2190</c>
<c>*0.10899318</c>
<c>*21404</c>
<c>* 0.09419454</c>
<c>*0.92191781</c>
<c>*0.10231732</c>
<c></c>
<c>* // 定义缩小比例</c>
<l>ScaleFactorX := 1</l>
<l>ScaleFactorY := PixelAccuracyY/(PixelAccuracyX+0.0000001)</l>
<c>* // 根据需要调整这个比例</c>
<l>zoom_region (RegionUnionFT, RegionUnionFTZoom, ScaleFactorX, ScaleFactorY)</l>
<c></c>
<c></c>
<c>***************************角度计算开始****************************************</c>
<l>smallest_rectangle2 (RegionUnionFTZoom, Row1, Column1, Phi1, Length11, Length21)</l>
<l>AngleRadiansH:=[]</l>
<l>tuple_abs(Phi1,AngleRadians1)</l>
<l>if(AngleRadians1&gt;0.785)</l>
<l>    AngleRadians2 :=3.1415926/2-AngleRadians1</l>
<l>    AngleRadiansH:=[AngleRadiansH,AngleRadians1]</l>
<l>    AngleRadiansH:=[AngleRadiansH,AngleRadians2]</l>
<c></c>
<l>  if(Phi1&gt;0 and AngleRadians1&gt;0.785)</l>
<c></c>
<l>    AngleRadians:=min(AngleRadiansH)</l>
<l>  else</l>
<l>    AngleRadians:=-min(AngleRadiansH)</l>
<l>  endif</l>
<l>else</l>
<l>  if(Phi1&gt;0)</l>
<l>    AngleRadians:=-Phi1</l>
<l>  else</l>
<l>    AngleRadians:=AngleRadians1</l>
<l>  endif</l>
<l>endif</l>
<c>*************************************角度计算结束********************************************</c>
<c>* 创建仿射变换矩阵 </c>
<l>hom_mat2d_identity(HomMat2D) </l>
<c></c>
<l>hom_mat2d_rotate(HomMat2D, AngleRadians, 0, 0, HomMat2DRotated) </l>
<c></c>
<c>* 应用仿射变换 </c>
<l>affine_trans_region(RegionUnionFTZoom, TransformedRegion, HomMat2DRotated, 'nearest_neighbor')</l>
<c>*******缩小展示开始**********************************</c>
<l>if(Width_Image&lt;Height_Image)</l>
<l>hom_mat2d_rotate(HomMat2D, AngleRadians+3.1415926/2, 0, 0, HomMat2DRotated1) </l>
<l>affine_trans_region(RegionUnionFTZoom, TransformedRegion1, HomMat2DRotated1, 'nearest_neighbor')</l>
<l>else</l>
<l>  TransformedRegion1:= TransformedRegion</l>
<l>endif</l>
<l>zoom_region (TransformedRegion1, RegionZoom, 0.1, 0.1)</l>
<l>area_center (RegionZoom, Area, Row, Column)</l>
<l>region_features (RegionZoom, 'width', ValueW)</l>
<l>region_features (RegionZoom, 'height', ValueH)</l>
<l>RowMove:=((ValueH+400)/2-Row)</l>
<l>ColumMove:=((ValueW+600)/2-Column)</l>
<l>move_region (RegionZoom, RegionMoved, RowMove, ColumMove)</l>
<l>dilation_circle (RegionMoved, RegionDilation, 1.5)</l>
<l>region_to_bin (RegionDilation, OutLineImage, 255, 0, ValueW+600, ValueH+400)</l>
<c>*******缩小展示结束**********************************</c>
<c>*图2旋转</c>
<l>affine_trans_image (Image2, ImageAffineTrans, HomMat2DRotated, 'constant', 'false')</l>
<l>affine_trans_image (Image1, ImageAffineTrans1, HomMat2DRotated, 'constant', 'false')</l>
<l>affine_trans_image (Image4, ImageAffineTrans4, HomMat2DRotated, 'constant', 'false')</l>
<c></c>
<l>fill_up (TransformedRegion, RegionFilledTrans)</l>
<c></c>
<c></c>
<l>closing_rectangle1 (RegionFilledTrans, RegionClosingTrans, 1, 1000)</l>
<l>closing_rectangle1 (RegionClosingTrans, RegionfullTrans, 1000, 1)</l>
<c></c>
<l>area_center (RegionfullTrans, AreaPanel, RowPanel, ColumnPanel)</l>
<c></c>
<c>***门夹提取**************</c>
<c></c>
<l>difference (RegionfullTrans, RegionFilledTrans, RegionDifferenceMJ)</l>
<l>opening_rectangle1 (RegionDifferenceMJ, RegionOpeningMJ, 10, 1)</l>
<l>connection (RegionOpeningMJ, ConnectedRegionsMJ)</l>
<l>select_shape (ConnectedRegionsMJ, SelectedRegionsMJ , 'area', 'and', 10000, 999999999)</l>
<l>select_shape (SelectedRegionsMJ, SelectedRegionsMJ, 'compactness', 'and', 0, 2)</l>
<c></c>
<c>*孔提取</c>
<l>difference (RegionFilledTrans, TransformedRegion, RegionDifferenceHoles)</l>
<l>connection (RegionDifferenceHoles, ConnectedRegionsHoles)</l>
<l>select_shape (ConnectedRegionsHoles, SelectedHolesT, 'area', 'and', 1000, 999999)</l>
<l>select_shape (SelectedHolesT, SelectedHolesT, 'roundness', 'and', 0.8, 1)</l>
<c></c>
<c></c>
<l>concat_obj (SelectedRegionsMJ, SelectedHolesT, SelectedRegionsQK)</l>
<c></c>
<c>***外围轮廓提取************** </c>
<l>opening_circle (TransformedRegion, RegionContour, 3.5)</l>
<l>GlassOutline:=RegionContour</l>
<l>region_features (RegionfullTrans, 'column1', Regionfullcolumn1)</l>
<l>region_features (RegionfullTrans, 'column2', Regionfullcolumn2)</l>
<l>height_width_ratio (RegionfullTrans, HeightRegionfull, WidthRegionfull, RatioRegionfull)</l>
<l>region_features (RegionfullTrans, 'row1', row1_Regionfull)</l>
<l>region_features (RegionfullTrans, 'row2', row2_Regionfull)</l>
<l>num:=HeightRegionfull/10</l>
<l>width_Regionfull:=[]</l>
<l>for i := 1 to 9 by 1</l>
<l>    gen_region_line (RegionLinesV, num*i+row1_Regionfull, 0, num*i+row1_Regionfull, Width_Image)</l>
<l>    intersection (RegionLinesV, RegionfullTrans, RegionIntersectionV)</l>
<l>    region_features (RegionIntersectionV, 'area', Value)</l>
<l>    width_Regionfull:=[width_Regionfull,Value]</l>
<c>    </c>
<l>endfor</l>
<l>tuple_length (width_Regionfull, LengthLinesV)</l>
<l>tuple_mean (width_Regionfull, width_Mean)</l>
<c></c>
<l>tuple_length (width_Regionfull, LengthLinesV)</l>
<l>tuple_mean (width_Regionfull, width_Mean)</l>
<c></c>
<l>region_features (RegionfullTrans, 'column1', column1_Regionfull)</l>
<l>numW:=WidthRegionfull/10</l>
<l>height_Regionfull:=[]</l>
<l>for i := 1 to 9 by 1</l>
<l>    gen_region_line (RegionLinesH, 0, numW*i+column1_Regionfull, row2_Regionfull+1000, numW*i+column1_Regionfull)</l>
<l>    intersection (RegionLinesH, RegionfullTrans, RegionIntersectionH)</l>
<l>    region_features (RegionIntersectionH, 'area', Value)</l>
<l>    height_Regionfull:=[height_Regionfull,Value]</l>
<c>    </c>
<l>endfor</l>
<l>tuple_length (height_Regionfull, LengthLinesH)</l>
<l>tuple_mean (height_Regionfull, height_Mean)</l>
<c></c>
<c></c>
<c></c>
<l> Cam1pixValue:=0     </l>
<l> Cam2pixValue:=0</l>
<l>cam1pix:=Cam1pixs-Regionfullcolumn1</l>
<l>if(cam1pix&lt;0)</l>
<l>   cam1pix:=0 </l>
<l>   cam2pix:=width_Mean</l>
<l>      Cam2pixValue:=(2*Cam2pixSetValue+KxCam2*(Regionfullcolumn1-Cam1Width+Tile2Column1)+KxCam2*(Regionfullcolumn2+Tile2Column1-Cam1Width))/2.000000 </l>
<l>else</l>
<l>    if(cam1pix&gt;width_Mean)</l>
<l>        cam1pix:=width_Mean</l>
<l>        cam2pix:=0</l>
<l>        Cam1pixValue:=Cam1pixSetValue+(KxCam1*(Regionfullcolumn1+Regionfullcolumn2+2*Tile2Column1))/2.000000              </l>
<l>    else        </l>
<l>        cam2pix:=width_Mean-cam1pix </l>
<l>        Cam1pixValue:=Cam1pixSetValue+(KxCam1*(Regionfullcolumn1+Tile2Column1)+KxCam1*Cam1Width)/2.000000</l>
<l>        Cam2pixValue:=Cam2pixSetValue+(KxCam2*(Regionfullcolumn2-Cam1pixs))/2.000000       </l>
<l>    endif</l>
<l>endif</l>
<c></c>
<c></c>
<c></c>
<l>gen_contour_region_xld (RegionfullTrans, Contours, 'border')</l>
<l>segment_contours_xld (Contours, ContoursSplit, 'lines_circles', 5, 4, 2)</l>
<l>union_collinear_contours_xld (ContoursSplit, UnionContours, 10, 1, 10, 0.5, 'attr_keep')</l>
<l>elliptic_axis_xld (UnionContours, Ra, Rb, Phi)</l>
<l>fit_line_contour_xld (UnionContours, 'tukey', -1, 0, 5, 2, RowBegin, ColBegin, RowEnd, ColEnd, Nr, Nc, Dist)</l>
<l>gen_region_line (RegionLines, RowBegin, ColBegin, RowEnd,ColEnd)  </l>
<c>   *水平线</c>
<l>   select_shape (RegionLines, RegionLinesV, 'width', 'and', 0.5*RegionsWidth, 999999999)  </l>
<l>   count_obj (RegionLinesV, NumberVer)</l>
<l>if(NumberVer&gt;0) </l>
<l>   region_features (RegionLinesV, 'orientation', ValueOriV)</l>
<l>   region_features (RegionLinesV, 'row', rowOriV)</l>
<l>    gen_empty_obj (Contours11X)</l>
<l>     gen_empty_obj (Contours12X)</l>
<c>   ***上侧边缘提取</c>
<l>   c:=(((ValueOriV[&gt;]3.1 and ValueOriV[&lt;]3.17) or (ValueOriV[&lt;]0.05 and ValueOriV[&gt;]-0.03)) and rowOriV[&lt;]RowPanel)</l>
<l>   d:=find(c,1)</l>
<l>   if(d!=-1)</l>
<l>     select_obj (RegionLinesV, RegionLinesVSelected, d+1)</l>
<l>     select_shape_std (RegionLinesVSelected, RegionLinesVSelectedstd, 'max_area', 70)</l>
<l>     gen_contour_region_xld (RegionLinesVSelectedstd, LinesVContours, 'border') </l>
<l>     count_obj (LinesVContours, NumberVContours)</l>
<l>    x1:=0</l>
<l>       if(NumberVContours&gt;0)          </l>
<l>            Contours11X:=LinesVContours</l>
<l>            elliptic_axis_xld (Contours11X, Ra1, Rb1, Phi11X)</l>
<l>            x1:=1</l>
<l>       endif</l>
<c>      </c>
<l>   endif</l>
<l>   region_features (RegionLinesVSelectedstd, 'phi', Value1)</l>
<c>   </c>
<l>   tuple_deg (Value1, Deg)</l>
<c>      ***下侧边缘提取</c>
<l>   c:=(((ValueOriV[&gt;]3.1 and ValueOriV[&lt;]3.17) or (ValueOriV[&lt;]0.05 and ValueOriV[&gt;]-0.03)) and rowOriV[&gt;]RowPanel)</l>
<l>   d:=find(c,1)</l>
<l>   if(d!=-1)</l>
<l>     select_obj (RegionLinesV, RegionLinesVSelected, d+1)</l>
<l>     select_shape_std (RegionLinesVSelected, RegionLinesVSelectedstd, 'max_area', 70)</l>
<l>     gen_contour_region_xld (RegionLinesVSelectedstd, LinesVContours, 'border') </l>
<l>     count_obj (LinesVContours, NumberVContours)</l>
<l>       x2:=0</l>
<l>       if(NumberVContours&gt;0)          </l>
<l>            Contours12X:=LinesVContours</l>
<l>            elliptic_axis_xld (Contours12X, Ra1, Rb1, Phi12X)</l>
<l>            x2:=1</l>
<l>       endif</l>
<c>      </c>
<l>   endif</l>
<l>       if(x1=1 and x2=1)  </l>
<l>        phiX:=Phi12X+Phi11X</l>
<l>        tuple_abs (phiX, Abs)</l>
<l>        distance_cc_min (Contours11X, Contours12X, 'fast_point_to_segment', DistanceHMin)</l>
<l>        GlassHeight:=DistanceHMin*pixValue</l>
<l>       else</l>
<l>         GlassHeight:=0  </l>
<l>       endif</l>
<l>       GlassHeight:=height_Mean*pixValue</l>
<l>endif</l>
<c></c>
<c></c>
<c>   *竖线</c>
<l>   select_shape (RegionLines, RegionLinesHSelected, 'ra', 'and', 500, 9999999999)</l>
<l>   count_obj (RegionLinesHSelected, NumberHor)</l>
<l>if(NumberHor&gt;0)    </l>
<l>   region_features (RegionLinesHSelected, 'orientation', ValueOriH)</l>
<l>   region_features (RegionLinesHSelected, 'column', columnOriH)</l>
<l>   gen_empty_obj (Contours11Y)</l>
<l>   gen_empty_obj (Contours12Y)</l>
<c>   ****右侧边缘提取</c>
<l>   c:=(((ValueOriH[&gt;]1.54 and ValueOriH[&lt;]1.6) or (ValueOriH[&lt;]-1.54 and ValueOriH[&gt;]-1.6)) and columnOriH[&gt;]ColumnPanel)</l>
<l>   x3:=0</l>
<l>   d:=find(c,1)</l>
<l>   if(d!=-1)</l>
<l>        select_obj (RegionLinesHSelected, RegionLinesHSelected1, d+1)</l>
<l>        count_obj (RegionLinesHSelected1, NumberLinesH)</l>
<c>        </c>
<l>            select_shape_std (RegionLinesHSelected1, SelectedLinesHstd, 'max_area', 70)</l>
<l>            gen_contour_region_xld (SelectedLinesHstd, Contours11Y, 'border')</l>
<l>            x3:=1</l>
<c>   </c>
<l>   endif</l>
<c>       ****左侧边缘提取</c>
<l>   c:=(((ValueOriH[&gt;]1.54 and ValueOriH[&lt;]1.6) or (ValueOriH[&lt;]-1.54 and ValueOriH[&gt;]-1.6)) and columnOriH[&lt;]ColumnPanel)</l>
<l>   d:=find(c,1)</l>
<l>   x4:=0</l>
<l>   if(d!=-1)</l>
<l>        select_obj (RegionLinesHSelected, RegionLinesHSelected2, d+1)</l>
<l>        count_obj (RegionLinesHSelected2, NumberLinesH)</l>
<c>        </c>
<l>            select_shape_std (RegionLinesHSelected2, SelectedLinesHstd, 'max_area', 70)</l>
<l>            gen_contour_region_xld (SelectedLinesHstd, Contours12Y, 'border')</l>
<l>            x4:=1</l>
<c>        </c>
<l>   endif</l>
<c>  </c>
<l>   if(x3=1 and x4=1)</l>
<l>   distance_cc_min (Contours11Y, Contours12Y, 'point_to_point', DistanceWMin)</l>
<l>        GlassWidth:=DistanceWMin*pixValue</l>
<l>   else</l>
<l>      GlassWidth:=0 </l>
<l>   endif</l>
<l>   GlassWidth:=cam1pix*Cam1pixValue+cam2pix*Cam2pixValue</l>
<l>endif</l>
<c></c>
<c>****测量标准***************************************</c>
<l>GlassCriterionW:=10</l>
<l>GlassCriterionH:=10</l>
<l>GlassErrRange:=1</l>
<l>GlassOK:='OK'</l>
<c>****测量标准***************************************</c>
<c></c>
<l>siyienable:=1</l>
<l>if(siyienable=1)</l>
<c>***************************************siyin门夹匹配开始***************************</c>
<l>threshold (ImageAffineTrans, Region, 30, 255)</l>
<l>fill_up (Region, RegionFillUp)</l>
<l>erosion_circle (RegionFillUp, RegionErosion, 100.5)</l>
<l>connection (RegionErosion, ConnectedRegions)</l>
<l>select_shape_std (ConnectedRegions, SelectedRegions, 'max_area', 70)</l>
<l>reduce_domain (ImageAffineTrans4, SelectedRegions, ImageReduced4)</l>
<l>threshold (ImageReduced4, RegionThresh, 0, 70)</l>
<l>connection (RegionThresh, ConnectedRegions1)</l>
<c></c>
<l>select_shape (ConnectedRegions1, SelectedRegions4, 'area', 'and', 5, 9999)</l>
<l>union1 (SelectedRegions4, RegionUnion)</l>
<l>closing_circle (RegionUnion, RegionClosing3, 100.5)</l>
<l>connection (RegionClosing3, ConnectedRegions2)</l>
<l>select_shape (ConnectedRegions2, SelectedRegions7, 'area', 'and', 10000, 99999999)</l>
<l>count_obj (SelectedRegions7, Number)</l>
<c>    </c>
<l>for Index := 1 to Number by 1</l>
<l>    select_obj (SelectedRegions7, ObjectSelected1, Index)</l>
<l>    intersection (ObjectSelected1, SelectedRegions4, RegionIntersection)</l>
<l>    connection (RegionIntersection, ConnectedRegions7)</l>
<l>    count_obj (ConnectedRegions7, Number7)  </l>
<l>    compactness (ObjectSelected1, Compactness)</l>
<l>    if(Number7&gt;2 and Compactness&lt;6)</l>
<c></c>
<l>        smallest_rectangle1 (ObjectSelected1, RowObj11, ColumnObj11, RowObj12, ColumnObj12)</l>
<l>        gen_rectangle1 (RectangleObj1, RowObj11, ColumnObj11, RowObj12, ColumnObj12)</l>
<l>        area_center (RectangleObj1, AreaObj1, RowSiyin, ColumnSiyin)</l>
<l>        height_width_ratio (RectangleObj1, HeightSiyin, WidthSiyin, Ratio)</l>
<c>        </c>
<l>        crop_part (ImageAffineTrans4, ImagePart1, RowSiyin-300, ColumnSiyin-600, 1200, 600)</l>
<l>        threshold (ImagePart1, Region4, 0, 255)</l>
<l>        concat_obj (SiYin, ImagePart1, SiYin)</l>
<c> </c>
<l> *       dyn_threshold (ImagePart3, ImageMean, RegionDynThresh, 40, 'dark')</l>
<l>        threshold (ImagePart1, Region3, 0, 70)</l>
<l>        connection (Region3, ConnectedRegions8)</l>
<l>        select_shape (ConnectedRegions8, SelectedRegions9, 'area', 'and', 5, 99999)</l>
<l>        union1 (SelectedRegions9, RegionUnion3)</l>
<l>        difference (Region4, RegionUnion3, RegionDifference2)</l>
<l>        paint_region (RegionDifference2, ImagePart1, rImage, 155, 'fill')</l>
<l>        concat_obj (siyinrImage, rImage, siyinrImage)</l>
<l>        siyinRow:=[siyinRow,RowSiyin]</l>
<l>        siyinColumn:=[siyinColumn,ColumnSiyin]</l>
<l>        siyinWidth:=[siyinWidth,WidthSiyin]</l>
<l>        siyinHeight:=[siyinHeight,HeightSiyin]</l>
<l> *        write_image (rImage, 'png', 0, 'D:/HalconFunction/siyinMoBan/1.bmp')</l>
<l>    endif</l>
<l>endfor</l>
<c></c>
<l>count_obj (SelectedRegionsMJ, NumberMJ)</l>
<l>for Index6 := 1 to NumberMJ by 1</l>
<l>    select_obj (SelectedRegionsMJ, ObjectSelected2, Index6)</l>
<l>    smallest_rectangle1 (ObjectSelected2, Row13, Column13, Row21, Column21)</l>
<l>    gen_rectangle1 (Rectangle1, Row13, Column13, Row21, Column21)</l>
<l>    area_center (Rectangle1, Area3, Row5, Column5)</l>
<c></c>
<l>    paint_region (ObjectSelected2, ImageAffineTrans, ImageResult2, 255, 'fill')</l>
<l>    if(Column5&gt;600 )</l>
<l>crop_part (ImageResult2, ImagePart2, Row5/ScaleFactorY-300, Column5-600, 1200, 600)</l>
<l>    else</l>
<l>  crop_part (ImageResult2, ImagePart2, Row5/ScaleFactorY-300, 0, 1200, 600)      </l>
<l>    endif</l>
<l>threshold (ImagePart2, Region5, 0, 254)</l>
<l>paint_region (Region5, ImagePart2, ImageResult, 0, 'fill')</l>
<l>concat_obj (menjiarImage, ImageResult, menjiarImage)</l>
<l> *write_image (ImageResult, 'png', 0, 'D:/HalconFunction/menjiaMoBan/1.bmp')</l>
<c></c>
<l>endfor</l>
<c>           </c>
<l>list_files ('D:/HalconFunction/siyinMoBan', 'files', Files)</l>
<l>Selection:=regexp_select(Files,'')</l>
<l>for Index4 := 0 to |Selection|-1 by 1</l>
<l>         read_image (ModelImage, Selection[Index4])</l>
<l>        get_image_size (ModelImage, Width, Height)</l>
<c>        </c>
<l>        get_model_region (ModelImage, RegionROI, ImageReduced, ModelImage)</l>
<l>        area_center (RegionROI, Area, RowModel, ColumnModel)</l>
<l>        dev_set_draw ('fill')</l>
<l>        dev_set_color ('green')</l>
<c>        * </c>
<c>        * Create a model for shape-based-matching.</c>
<l>        dev_display (RegionROI)</l>
<c>        * </c>
<c>        * Create a model for shape-based-matching.</c>
<l>        create_generic_shape_model (ModelID)</l>
<l>        set_generic_shape_model_param (ModelID, 'iso_scale_min', 0.6)</l>
<l>        set_generic_shape_model_param (ModelID, 'iso_scale_max', 1.02)</l>
<l>        train_generic_shape_model (ImageReduced, ModelID)</l>
<l>        set_generic_shape_model_param (ModelID, 'min_score', 0.3)</l>
<l>        set_generic_shape_model_param (ModelID, 'num_matches', 1)</l>
<l>        set_generic_shape_model_param (ModelID, 'max_overlap', 0)</l>
<l>        set_generic_shape_model_param (ModelID, 'pyramid_level_lowest', 3)</l>
<c>        * </c>
<c>        * Create a variation model for print inspection.</c>
<l>        create_variation_model (Width, Height, 'byte', 'direct', VariationID)</l>
<c>        * Generate the variation image.</c>
<l>        sobel_amp (ModelImage, VarImage, 'sum_abs', 3)</l>
<l>        prepare_direct_variation_model (ModelImage, VarImage, VariationID, [20, 25], [1.6, 1.6])</l>
<c>        * </c>
<c>        * Get the gray value range of the variation model to compensate</c>
<c>        * for the illumination changes.</c>
<l>        get_grayval_range (ModelImage, RegionROI, RegionForeground, RegionBackground, BackgroundGVModel, ForegroundGVModel)                      </l>
<l>        count_obj (siyinrImage, NumberSiyin)</l>
<l>        if(NumberSiyin&gt;0)</l>
<l>            for Index5 := 1 to NumberSiyin by 1</l>
<l>                select_obj (siyinrImage, ObjectSelectedr, Index5)</l>
<l>                  inspect_cap (ObjectSelectedr, RegionROI, RegionBackground, ModelID, VariationID, RowModel, ColumnModel, BackgroundGVModel, ForegroundGVModel, BackgroundGVal, ForegroundGVal, OKsiyin, NumMatchResult)</l>
<l>                      if(NumMatchResult&gt;0)</l>
<l>                        concat_obj (SiYinDefect, ObjectSelectedr, SiYinDefect)</l>
<l>                         typeSiYin:=[typeSiYin,'丝印']            </l>
<c>                         </c>
<l>                        if(OKsiyin=0)</l>
<l>                           SiYinOK:=[SiYinOK,'OK']  </l>
<l>                        else</l>
<l>                           SiYinOK:=[SiYinOK,'NG']   </l>
<l>                        endif</l>
<c>                        </c>
<l>                      endif</l>
<l>            endfor</l>
<l>        endif</l>
<c>                  </c>
<l>endfor</l>
<c></c>
<c>       </c>
<l>    list_files ('D:/HalconFunction/menjiaMoBan', 'files', Files)</l>
<l>Selection:=regexp_select(Files,'')</l>
<l>for Index5 := 0 to |Selection|-1 by 1</l>
<l>        read_image (ModelImage, Selection[Index5])</l>
<l>        get_image_size (ModelImage, Width, Height)</l>
<c>        </c>
<l>        get_modelMJ_region (ModelImage, RegionROI, ImageReduced, ModelImage)</l>
<l>        area_center (RegionROI, Area, RowModel, ColumnModel)</l>
<l>        dev_set_draw ('fill')</l>
<l>        dev_set_color ('green')</l>
<c>        * </c>
<c>        * Create a model for shape-based-matching.</c>
<l>        dev_display (RegionROI)</l>
<c>        * </c>
<c>        * Create a model for shape-based-matching.</c>
<l>        create_generic_shape_model (ModelID)</l>
<l>        set_generic_shape_model_param (ModelID, 'iso_scale_min', 0.6)</l>
<l>        set_generic_shape_model_param (ModelID, 'iso_scale_max', 1.02)</l>
<l>        train_generic_shape_model (ImageReduced, ModelID)</l>
<l>        set_generic_shape_model_param (ModelID, 'min_score', 0.3)</l>
<l>        set_generic_shape_model_param (ModelID, 'num_matches', 1)</l>
<l>        set_generic_shape_model_param (ModelID, 'max_overlap', 0)</l>
<l>        set_generic_shape_model_param (ModelID, 'pyramid_level_lowest', 3)</l>
<c>        * </c>
<c>        * Create a variation model for print inspection.</c>
<l>        create_variation_model (Width, Height, 'byte', 'direct', VariationID)</l>
<c>        * Generate the variation image.</c>
<l>        sobel_amp (ModelImage, VarImage, 'sum_abs', 3)</l>
<l>        prepare_direct_variation_model (ModelImage, VarImage, VariationID, [20, 25], [1.6, 1.6])</l>
<c>        * </c>
<c>        * Get the gray value range of the variation model to compensate</c>
<c>        * for the illumination changes.</c>
<l>        get_grayval_range (ModelImage, RegionROI, RegionForeground, RegionBackground, BackgroundGVModel, ForegroundGVModel)                      </l>
<l>        count_obj (menjiarImage, Number5)</l>
<l>        for Index5 := 1 to Number5 by 1</l>
<l>            select_obj (menjiarImage, ObjectSelectedr, Index5)</l>
<l>            inspectMJ_cap (ObjectSelectedr, RegionROI, RegionBackground, ModelID, VariationID, RowModel, ColumnModel, BackgroundGVModel, ForegroundGVModel, BackgroundGVal, ForegroundGVal, OKmenjia, NumMatchResult)</l>
<l>                  if(NumMatchResult&gt;0) </l>
<l>                    if(OKmenjia=0)</l>
<l>                       MJOK:=[MJOK,'OK']  </l>
<l>                    else</l>
<l>                       MJOK:=[MJOK,'NG']   </l>
<l>                    endif</l>
<c>                   </c>
<l>                  endif</l>
<l>        endfor</l>
<c>      </c>
<c>                  </c>
<l>endfor</l>
<c></c>
<l>endif</l>
<c></c>
<c></c>
<c>***************************************siyin门夹匹配结束***************************</c>
<l>region_features (SelectedHolesT, 'roundness', RegionsRoundness)</l>
<l>c:=(RegionsRoundness[&gt;]0.9)</l>
<l>d:=find(c,1)</l>
<l>if(d!=-1)</l>
<l>select_obj (SelectedHolesT, SelectedRegionsHoles, d+1)</l>
<l>count_obj (SelectedRegionsHoles, NumberH)</l>
<l>tuple_gen_const (NumberH, '孔', HolesTuple)</l>
<c> </c>
<c></c>
<l>count_obj (SelectedRegionsMJ, NumberMJ)</l>
<l>tuple_gen_const (NumberMJ, '门夹', MenJiaTuple)</l>
<l>tuple_concat (HolesTuple, MenJiaTuple, Type)</l>
<c></c>
<l>concat_obj (SelectedRegionsHoles, SelectedRegionsMJ, ObjectsConcatQK)</l>
<l>endif</l>
<c></c>
<l>count_obj (ObjectsConcatQK, NumberQK)</l>
<l>if(NumberQK&gt;0)  </l>
<l>smallest_rectangle1 (ObjectsConcatQK, Row11, Column11, Row12, Column12)</l>
<l>gen_rectangle1 (Rectangle, Row11/ScaleFactorY-50, Column11-50, Row12/ScaleFactorY+50, Column12+50)</l>
<l>  for Index2 := 1 to NumberQK by 1</l>
<l>    select_obj (Rectangle, ObjectSelected, Index2)</l>
<l>    reduce_domain (ImageAffineTrans, ObjectSelected, ImageReduced)</l>
<l>    crop_domain (ImageReduced, ImagePart)</l>
<l>    concat_obj (QKImage, ImagePart, QKImage)</l>
<l>  endfor</l>
<c></c>
<c>*****</c>
<l>area_center (ObjectsConcatQK, AreaQK, RowQK, ColumnQK)</l>
<l>region_features (SelectedRegionsHoles, 'width', width_Holes)</l>
<l>region_features (SelectedRegionsHoles, 'height', height_Holes)</l>
<l>QKWidth:=width_Holes*pixValue</l>
<l>QKHeight:=height_Holes*pixValue</l>
<c></c>
<c></c>
<l>region_features (SelectedRegionsMJ, 'width', width_MJ)</l>
<l>region_features (SelectedRegionsMJ, 'height', height_MJ)</l>
<l>QKWidth:=[QKWidth,width_MJ*pixValue]</l>
<l>QKHeight:=[QKHeight,height_MJ*pixValue]</l>
<c></c>
<c>**水平方向距离</c>
<l>dis_min1:=[]</l>
<l>dis_min2:=[]</l>
<l>distance_pc (Contours11X, RowQK, ColumnQK, DistanceMin1, DistanceMax1)</l>
<l>distance_pc (Contours12X, RowQK, ColumnQK, DistanceMin2, DistanceMax2)</l>
<l>dis_min1:= DistanceMin1</l>
<l>dis_min2:= DistanceMin2</l>
<l>count:=|dis_min1|</l>
<l>dismin_horn:=[]</l>
<l>for Index1 := 1 to count by 1</l>
<l>    tuple_select (dis_min1, Index1-1, Selected1)</l>
<l>    tuple_select (dis_min2, Index1-1, Selected2)    </l>
<l>    tuple_min2 (Selected1, Selected2, Min2) </l>
<l>    dismin_horn:=[dismin_horn,Min2]</l>
<l>endfor</l>
<l>DistanceHorizontal:=dismin_horn*pixValue</l>
<c>***dismin_horn水平距离结果</c>
<c></c>
<c>**SIYINX***</c>
<l>tuple_length (siyinRow, Length)</l>
<l>if(Length&gt;0)</l>
<l>dis_min1:=[]</l>
<l>dis_min2:=[]</l>
<l>distance_pc (Contours11X, siyinRow*ScaleFactorY, siyinColumn, DistanceMin1, DistanceMax1)</l>
<l>distance_pc (Contours12X, siyinRow*ScaleFactorY, siyinColumn, DistanceMin2, DistanceMax2)</l>
<l>dis_min1:= DistanceMin1</l>
<l>dis_min2:= DistanceMin2</l>
<l>count:=|dis_min1|</l>
<l>dismin_horn:=[]</l>
<l>for Index1 := 1 to count by 1</l>
<l>    tuple_select (dis_min1, Index1-1, Selected1)</l>
<l>    tuple_select (dis_min2, Index1-1, Selected2)    </l>
<l>    tuple_min2 (Selected1, Selected2, Min2) </l>
<l>    dismin_horn:=[dismin_horn,Min2]</l>
<l>endfor</l>
<l>SiYinDistanceHorizontal:=dismin_horn*pixValue</l>
<c></c>
<c>**SIYINY***</c>
<l>dis_min1:=[]</l>
<l>dis_min2:=[]</l>
<l>distance_pc (Contours11Y, siyinRow*ScaleFactorY, siyinColumn, DistanceMin1, DistanceMax1)</l>
<l>distance_pc (Contours12Y, siyinRow*ScaleFactorY, siyinColumn, DistanceMin2, DistanceMax2)</l>
<l>dis_min1:= DistanceMin1</l>
<l>dis_min2:= DistanceMin2</l>
<l>count:=|dis_min1|</l>
<l>dismin_horn:=[]</l>
<l>for Index1 := 1 to count by 1</l>
<l>    tuple_select (dis_min1, Index1-1, Selected1)</l>
<l>    tuple_select (dis_min2, Index1-1, Selected2)    </l>
<l>    tuple_min2 (Selected1, Selected2, Min2) </l>
<l>    dismin_horn:=[dismin_horn,Min2]</l>
<l>endfor</l>
<l>SiYinDistanceVertical:=dismin_horn*pixValue</l>
<c> </c>
<l>endif</l>
<c>**垂直方向距离</c>
<l>dis_min1:=[]</l>
<l>dis_min2:=[]</l>
<l>distance_pc (Contours11Y, RowQK, ColumnQK, DistanceMin1, DistanceMax1)</l>
<l>distance_pc (Contours12Y, RowQK, ColumnQK, DistanceMin2, DistanceMax2)</l>
<l>dis_min1:= DistanceMin1</l>
<l>dis_min2:= DistanceMin2</l>
<l>count:=|dis_min1|</l>
<l>dismin_ver:=[]</l>
<c></c>
<l>for Index1 := 1 to count by 1</l>
<l>    tuple_select (dis_min1, Index1-1, Selected1)</l>
<l>    tuple_select (dis_min2, Index1-1, Selected2)  </l>
<l>    tuple_min2 (Selected1, Selected2, Min2)</l>
<l>    dismin_ver:=[dismin_ver,Min2]  </l>
<l>endfor</l>
<l>DistanceVertical:=dismin_ver*pixValue</l>
<l>endif</l>
<c></c>
<c></c>
<c></c>
<c></c>
<c></c>
<l>CriterionX:=10</l>
<l>CriterionY:=10</l>
<l>CriterionW:=10</l>
<l>CriterionH:=10</l>
<l>ErrRange:=1</l>
<l>for Index3 := 1 to NumberH by 1</l>
<l>    QKOK:=[QKOK,'OK']</l>
<l>endfor</l>
<l>QKOK:=[QKOK,MJOK]</l>
<c></c>
<c>*****dismin_ver垂直距离</c>
<l>concat_obj (QKImage, SiYinDefect, HolesImage)</l>
<c></c>
<l>concat_obj (SiYinDefect, rImage, SiYinDefect)</l>
<l>             Type:=[Type,typeSiYin]</l>
<l>             QKOK:=[QKOK,SiYinOK]</l>
<l>             DistanceHorizontal:=[DistanceHorizontal,SiYinDistanceHorizontal]</l>
<l>             DistanceVertical:=[DistanceVertical,SiYinDistanceVertical]</l>
<l>             QKWidth:=[QKWidth,siyinWidth*pixValuesiyin]</l>
<l>             QKHeight:=[QKHeight,siyinHeight*pixValue]</l>
<c>*****************************************************************************************************</c>
<c>*************************收集数据******************************* </c>
<l>create_dict (ResultDictHoles)</l>
<l>set_dict_tuple (ResultDictHoles, 'GlassOK', GlassOK)</l>
<l>set_dict_tuple (ResultDictHoles, 'GlassHeight', GlassHeight)</l>
<l>set_dict_tuple (ResultDictHoles, 'GlassWidth', GlassWidth)</l>
<l>set_dict_tuple (ResultDictHoles, 'Type', Type)</l>
<l>set_dict_tuple (ResultDictHoles, 'HolesOK', QKOK)</l>
<l>set_dict_tuple (ResultDictHoles, 'DistanceHorizontal', DistanceHorizontal)</l>
<l>set_dict_tuple (ResultDictHoles, 'DistanceVertical', DistanceVertical)</l>
<l>set_dict_tuple (ResultDictHoles, 'HolesWidth', QKWidth)</l>
<l>set_dict_tuple (ResultDictHoles, 'HolesHeight', QKHeight)</l>
<c></c>
<c></c>
<l>return ()</l>
<l>catch (Exception)</l>
<l>   create_dict (ResultDictHoles)</l>
<l>GlassHeight:=0</l>
<l>GlassWidth:=0</l>
<l>set_dict_tuple (ResultDictHoles, 'GlassHeight', GlassHeight)</l>
<l>set_dict_tuple (ResultDictHoles, 'GlassWidth', GlassWidth)</l>
<c></c>
<l>endtry</l>
</body>
<docu id="ProcessHoles">
<parameters>
<parameter id="Cam1Width"/>
<parameter id="Cam1pixs"/>
<parameter id="DetectDict"/>
<parameter id="HolesImage"/>
<parameter id="Image1"/>
<parameter id="Image2"/>
<parameter id="Image3"/>
<parameter id="Image4"/>
<parameter id="OutLineImage"/>
<parameter id="ResultDictHoles"/>
<parameter id="Tile2Column1"/>
</parameters>
</docu>
</procedure>
</hdevelop>
