<?xml version="1.0" encoding="UTF-8"?>
<hdevelop file_version="1.2" halcon_version="22.05.0.0">
<procedure name="ProcessHoles">
<interface>
<io>
<par name="Image1" base_type="iconic" dimension="0"/>
<par name="Image2" base_type="iconic" dimension="0"/>
<par name="Image3" base_type="iconic" dimension="0"/>
<par name="Image4" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="OutLineImage" base_type="iconic" dimension="0"/>
<par name="HolesImage" base_type="iconic" dimension="0"/>
<par name="GlassContours" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="DetectDict" base_type="ctrl" dimension="0"/>
<par name="Cam1pixs" base_type="ctrl" dimension="0"/>
<par name="Cam1Width" base_type="ctrl" dimension="0"/>
<par name="Tile2Column1" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="ResultDictHoles" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>try</l>
<l>* set_system ('parallelize_operators', 'true')</l>
<l>*dev_update_off ()</l>
<l>* dev_update_time ('off')</l>
<l>* dev_update_pc ('off')</l>
<l>* dev_update_var ('off')</l>
<l>dev_update_window ('on')</l>
<l>set_system ('clip_region', 'false')</l>
<c>**********************初始化输出*****************************</c>
<l>set_system ('clip_region', 'false')</l>
<l>gen_empty_obj (SiYin)</l>
<l>gen_empty_obj (SiYinDefect)</l>
<l>gen_empty_obj (RegionMJ)</l>
<l>Phi11X:=0</l>
<l>Phi12X:=0</l>
<l>Abs:=0</l>
<l>typeSiYin:=[]</l>
<l>SiYinOK:=[]</l>
<l>SiYinDistanceHorizontal:=[]</l>
<l>SiYinDistanceVertical:=[]</l>
<l>siyinWidth:=[]</l>
<l>siyinHeight:=[]</l>
<l>pingjieposition:=0 </l>
<l>NumberH:=0</l>
<l>NumberMJ:=0</l>
<l>dev_set_draw ('fill')</l>
<l>GlassOK:=[]</l>
<l>QKOK:=[]</l>
<l>MJOK:=[]</l>
<l>QKWidth:=[]</l>
<l>QKHeight:=[]</l>
<l>siyinRow:=[]</l>
<l>siyinColumn:=[]</l>
<l>Type:=[]</l>
<l>DistanceHorizontal:=[]</l>
<l>DistanceVertical:=[]</l>
<l>siyinRowM:=[]</l>
<l>siyinColumnM:=[]</l>
<l>siyinWidthM:=[]</l>
<l>siyinHeightM:=[]</l>
<l>gen_empty_obj (HolesImage)</l>
<l>gen_empty_obj (QKImage)</l>
<l>gen_empty_obj (TransformedRegion)</l>
<l>gen_empty_obj (OutLineImage)</l>
<l>gen_empty_obj(LinesVContours)</l>
<l>gen_empty_obj(LinesHContours)</l>
<l>gen_empty_obj(SelectedRegionsHoles)</l>
<l>gen_empty_obj(SelectedRegionsMJ)</l>
<l>gen_empty_obj(ObjectsConcatQK)</l>
<l>gen_empty_obj (siyinrImage)</l>
<l>gen_empty_obj (menjiarImage)</l>
<l>gen_empty_obj (rImage)</l>
<l>get_image_size (Image3, Width_Image, Height_Image)</l>
<l>pixValueBottom:=0.102796558</l>
<l>Cam1pixSetValue:=0</l>
<l>Cam2pixSetValue:=0</l>
<c>*0.10226235</c>
<l>get_dict_tuple (DetectDict,'尺寸测量', MersureDict)</l>
<l>get_dict_tuple (MersureDict,'相机1像素0精度', Cam1pixSetValue)</l>
<l>get_dict_tuple (MersureDict,'相机2与相机1精度比值', CamPixRatio)</l>
<l>get_dict_tuple (MersureDict,'相机1像素k值', KxCam1)</l>
<l>get_dict_tuple (MersureDict,'相机2像素k值', KxCam2)</l>
<l>get_dict_tuple (DetectDict,'缺陷检测', detectDict)</l>
<l>get_dict_tuple (detectDict,'玻璃厚度' , thickness)</l>
<l>get_dict_tuple (detectDict,'丝印离辊道距离' , siyindistance)</l>
<l>Cam1Width:=8000</l>
<l>Cam1pixSetValue:=Cam1pixSetValue*(1457.7-(thickness-6))/1457.700</l>
<l>pixValueC1:=(2*Cam1pixSetValue+KxCam1*Cam1Width)/2.000000</l>
<l>pixValueC2:=(2*Cam1pixSetValue*CamPixRatio+KxCam2*Cam1Width)/2.000000</l>
<l>pixValueSetV:=(pixValueC1+pixValueC2)/2.000000</l>
<l>Cam2pixSetValue:=CamPixRatio*Cam1pixSetValue</l>
<c></c>
<l>get_dict_tuple (DetectDict,'编码器参数', CodeDict)</l>
<l>get_dict_tuple (CodeDict,'编码器转数', CodeNumPr)</l>
<l>get_dict_tuple (CodeDict,'辊道周长', RollerPer)</l>
<l>get_dict_tuple (CodeDict,'每行对应的编码计数', CodeCountPerLine)</l>
<c></c>
<l>pixValue:=pixValueSetV</l>
<l>get_dict_tuple (MersureDict,'相机1像素0精度', Cam1pixSetValue)</l>
<l>Cam1pixSetValuesiyin:=Cam1pixSetValue*(1457.7-(siyindistance-6))/1457.700</l>
<l>pixValueC1siyin:=(2*Cam1pixSetValuesiyin+KxCam1*Cam1Width)/2.000000</l>
<l>pixValueC2siyin:=(2*Cam1pixSetValuesiyin*CamPixRatio+KxCam2*Cam1Width)/2.000000</l>
<l>pixValueSetVsiyin:=(pixValueC1siyin+pixValueC2siyin)/2.000000</l>
<l>pixValuesiyin:=pixValueSetVsiyin</l>
<c></c>
<l>DistanceHorizontal:=[]</l>
<l>DistanceVertical:=[]</l>
<l>HolesHeight:=[]</l>
<l>HolesWidth:=[]</l>
<l>GlassWidth:=[]</l>
<l>GlassHeight:=[]</l>
<l>GlassAngle:=[]</l>
<c></c>
<l>threshold (Image2, RegionFL, 20, 255)</l>
<l>opening_circle (RegionFL, RegionOpeningFL, 13.5)</l>
<c></c>
<l>connection (RegionOpeningFL, ConnectedRegionsFL)</l>
<l>select_shape_std (ConnectedRegionsFL, SelectedRegionsFL, 'max_area', 70)</l>
<l>closing_rectangle1 (SelectedRegionsFL, SelectedRegionsFL, 1, 10)</l>
<c></c>
<l>region_features (SelectedRegionsFL, 'width', RegionsWidth)</l>
<l>erosion_circle (SelectedRegionsFL, RegionErosionFL, 20.5)</l>
<l>difference (SelectedRegionsFL, RegionErosionFL, RegionDifferenceFL)</l>
<l>opening_rectangle1 (RegionDifferenceFL, RegionOpening1FL, 30, 1)</l>
<l>connection (RegionOpening1FL, ConnectedRegions2FL)</l>
<l>select_shape (ConnectedRegions2FL, SelectedRegions1FL, 'width', 'and', 0.8*RegionsWidth, 2*RegionsWidth)</l>
<l>dilation_circle (SelectedRegions1FL, RegionDilationFL, 100.5)</l>
<c></c>
<c></c>
<c></c>
<l>threshold (Image1, RegionTL, 0, 20)</l>
<l>intersection (RegionDilationFL, RegionTL, RegionIntersectionFT)</l>
<l>connection (RegionIntersectionFT, ConnectedRegionsTL)</l>
<l>select_shape (ConnectedRegionsTL, SelectedRegionsTL, 'width', 'and', 0.8*RegionsWidth, 2*RegionsWidth)</l>
<c></c>
<c>*反射亮场和透射亮region拼接</c>
<l>union2 (SelectedRegionsTL, SelectedRegionsFL, RegionUnionFT1)</l>
<l>union1 (RegionUnionFT1, RegionUnionFT1)</l>
<l>closing_circle (RegionUnionFT1, RegionClosingFT, 13.5)</l>
<c></c>
<c></c>
<c>***玻璃轮廓填充************</c>
<l>closing_rectangle1 (RegionClosingFT, RegionClosingFT2, 1, 1000)</l>
<l>closing_rectangle1 (RegionClosingFT2, RegionFilled, 1000, 1)</l>
<l>erosion_circle (RegionFilled, RegionFilled, 30.5)</l>
<l>reduce_domain (Image2, RegionFilled, ImageReduced2)</l>
<c></c>
<c></c>
<l>threshold (ImageReduced2, RegionH, 0, 60)</l>
<l>connection (RegionH, ConnectedRegionsH)</l>
<l>select_shape (ConnectedRegionsH, SelectedRegionsH, 'area', 'and', 5000, 999999)</l>
<l>select_shape (SelectedRegionsH, SelectedRegionsH, 'roundness', 'and', 0.8, 1)</l>
<l>fill_up (SelectedRegionsH, RegionFillUpH)</l>
<c></c>
<l>union1 (RegionFillUpH, RegionUnionH)</l>
<l>difference (RegionClosingFT, RegionUnionH, RegionUnionFT)</l>
<c></c>
<l>PixelAccuracyX:=pixValue</l>
<l>*pixYValueCal:=(RollerPer/1000.000000)/((CodeNumPr*4)/4.000000)</l>
<l>pixYValueCal:=(RollerPer/1000.000000)/((CodeNumPr*4)/(CodeCountPerLine+0.000001))</l>
<c></c>
<l>get_dict_tuple (MersureDict,'Y方向精度K', Ky)</l>
<l>get_dict_tuple (MersureDict,'Y方向精度B', By)</l>
<c></c>
<l>PixelAccuracyY:=Ky*pixYValueCal</l>
<c>*0.10902//2190</c>
<c>*0.10899318</c>
<c>*21404</c>
<c>* 0.09419454</c>
<c>*0.92191781</c>
<c>*0.10231732</c>
<c></c>
<c>* // 定义缩小比例</c>
<l>ScaleFactorX := 1</l>
<l>ScaleFactorY := PixelAccuracyY/(PixelAccuracyX+0.0000001)</l>
<c>* // 根据需要调整这个比例</c>
<l>zoom_region (RegionUnionFT, RegionUnionFTZoom, ScaleFactorX, ScaleFactorY)</l>
<c></c>
<c>*240708新增</c>
<l>reduce_domain (Image1, RegionFilled, ImageReduced1)</l>
<l>threshold (ImageReduced1, Region1, 0, 100)</l>
<l>connection (Region1, ConnectedRegions3)</l>
<l>fill_up (ConnectedRegions3, RegionFillUp1)</l>
<l>select_shape (RegionFillUp1, SelectedRegions1, 'circularity', 'and', 0.6, 1)</l>
<l>select_shape (SelectedRegions1, SelectedRegions2, 'area', 'and', 5000, 999999999)</l>
<l>intersection (SelectedRegions2, ConnectedRegions3, RegionIntersection1)</l>
<l>difference (SelectedRegions2, RegionIntersection1, RegionDifference)</l>
<l>connection (RegionDifference, ConnectedRegions4)</l>
<l>select_shape (ConnectedRegions4, SelectedRegions3, 'area', 'and', 3000, 999999999)</l>
<l>select_shape (SelectedRegions3, SelectedRegions3, 'circularity', 'and', 0.7, 1)</l>
<l>union1 (SelectedRegions3, RegionUnion1)</l>
<l>zoom_region (RegionUnion1, RegionZoom2, ScaleFactorX, ScaleFactorY)</l>
<c></c>
<c></c>
<c>***************************角度计算开始****************************************</c>
<l>smallest_rectangle2 (RegionUnionFTZoom, Row1, Column1, Phi1, Length11, Length21)</l>
<l>AngleRadiansH:=[]</l>
<l>tuple_abs(Phi1,AngleRadians1)</l>
<l>if(AngleRadians1&gt;0.785)</l>
<l>    AngleRadians2 :=3.1415926/2-AngleRadians1</l>
<l>    AngleRadiansH:=[AngleRadiansH,AngleRadians1]</l>
<l>    AngleRadiansH:=[AngleRadiansH,AngleRadians2]</l>
<c></c>
<l>  if(Phi1&gt;0 and AngleRadians1&gt;0.785)</l>
<c></c>
<l>    AngleRadians:=min(AngleRadiansH)</l>
<l>  else</l>
<l>    AngleRadians:=-min(AngleRadiansH)</l>
<l>  endif</l>
<l>else</l>
<l>  if(Phi1&gt;0)</l>
<l>    AngleRadians:=-Phi1</l>
<l>  else</l>
<l>    AngleRadians:=AngleRadians1</l>
<l>  endif</l>
<l>endif</l>
<l>GlassAngle:=[GlassAngle,AngleRadians]</l>
<c>*************************************角度计算结束********************************************</c>
<c>* 创建仿射变换矩阵 </c>
<l>hom_mat2d_identity(HomMat2D) </l>
<c></c>
<l>hom_mat2d_rotate(HomMat2D, AngleRadians, 0, 0, HomMat2DRotated) </l>
<c></c>
<c>* 应用仿射变换 </c>
<l>affine_trans_region(RegionUnionFTZoom, TransformedRegion, HomMat2DRotated, 'nearest_neighbor')</l>
<c>*240708新增</c>
<l>affine_trans_region(RegionZoom2, TransformedRegionTL, HomMat2DRotated, 'nearest_neighbor')</l>
<l>connection (TransformedRegionTL, TransConnectedRegionsTL)</l>
<l>select_shape (TransConnectedRegionsTL, TransSelectedRegionsTL, 'area', 'and', 150, 999999999)</l>
<c></c>
<c></c>
<l>smallest_rectangle1 (TransformedRegion, RowRegion1, ColumnRegion1, RowRegion2, ColumnRegion2)</l>
<l>move_region (TransformedRegion, RegionMoved1, -RowRegion1, -ColumnRegion1)</l>
<c></c>
<c></c>
<c></c>
<c>*******缩小展示开始**********************************</c>
<l>if(Width_Image&lt;Height_Image)</l>
<l>hom_mat2d_rotate(HomMat2D, AngleRadians+3.1415926/2, 0, 0, HomMat2DRotated1) </l>
<l>affine_trans_region(RegionUnionFTZoom, TransformedRegion1, HomMat2DRotated1, 'nearest_neighbor')</l>
<l>else</l>
<l>  TransformedRegion1:= TransformedRegion</l>
<l>endif</l>
<l>zoom_region (TransformedRegion1, RegionZoom, 0.1, 0.1)</l>
<l>area_center (RegionZoom, Area, Row, Column)</l>
<l>region_features (RegionZoom, 'width', ValueW)</l>
<l>region_features (RegionZoom, 'height', ValueH)</l>
<l>RowMove:=((ValueH+400)/2-Row)</l>
<l>ColumMove:=((ValueW+600)/2-Column)</l>
<l>move_region (RegionZoom, RegionMoved, RowMove, ColumMove)</l>
<l>dilation_circle (RegionMoved, RegionDilation, 1.5)</l>
<l>region_to_bin (RegionDilation, OutLineImage, 255, 0, ValueW+600, ValueH+400)</l>
<c>*******缩小展示结束**********************************</c>
<c>*图2旋转</c>
<l>affine_trans_image (Image2, ImageAffineTrans, HomMat2DRotated, 'constant', 'false')</l>
<l>affine_trans_image (Image1, ImageAffineTrans1, HomMat2DRotated, 'constant', 'false')</l>
<l>affine_trans_image (Image4, ImageAffineTrans4, HomMat2DRotated, 'constant', 'false')</l>
<c></c>
<l>fill_up (TransformedRegion, RegionFilledTrans)</l>
<l>opening_rectangle1 (RegionFilledTrans, RegionFilledTrans, 1, 150)</l>
<c></c>
<c></c>
<c></c>
<l>closing_rectangle1 (RegionFilledTrans, RegionClosingTrans, 1, 1000)</l>
<l>closing_rectangle1 (RegionClosingTrans, RegionfullTrans, 1000, 1)</l>
<c></c>
<l>area_center (RegionfullTrans, AreaPanel, RowPanel, ColumnPanel)</l>
<c></c>
<c>***门夹提取**************</c>
<c></c>
<l>difference (RegionfullTrans, RegionFilledTrans, RegionDifferenceMJ)</l>
<l>opening_rectangle1 (RegionDifferenceMJ, RegionOpeningMJ, 10, 1)</l>
<l>connection (RegionOpeningMJ, ConnectedRegionsMJ)</l>
<l>select_shape (ConnectedRegionsMJ, SelectedRegionsMJ , 'area', 'and', 50000, 999999999)</l>
<l>select_shape (SelectedRegionsMJ, SelectedRegionsMJ, 'compactness', 'and', 0, 3)</l>
<c></c>
<c>*孔提取</c>
<l>difference (RegionFilledTrans, TransformedRegion, RegionDifferenceHoles)</l>
<l>connection (RegionDifferenceHoles, ConnectedRegionsHoles)</l>
<l>select_shape (ConnectedRegionsHoles, SelectedHolesT, 'area', 'and', 1000, 999999)</l>
<l>* select_shape (SelectedHolesT, SelectedHolesT, 'roundness', 'and', 0.8, 1)</l>
<l>select_shape (SelectedHolesT, SelectedHolesT, 'roundness', 'and', 0.86, 1)</l>
<l>concat_obj (SelectedRegionsMJ, SelectedHolesT, SelectedRegionsQK)</l>
<c></c>
<c></c>
<c></c>
<c></c>
<c>*** 0715：提取门夹的中心坐标和尺寸 ************** </c>
<c></c>
<l>* edges_image (Image1, ImaAmp, ImaDir, 'canny', 1, 'nms', 20, 40)</l>
<l>* threshold (ImaDir, Region1, 0, 250)</l>
<l>* closing_circle (Region1, RegionClosing1, 10)</l>
<l>* fill_up (RegionClosing1, RegionFillUp1)</l>
<c></c>
<l>sobel_amp (Image1, EdgeAmplitude, 'sum_abs', 3)</l>
<l>threshold (EdgeAmplitude, Region1, 15, 250)</l>
<l>connection (Region1, ConnectedRegions9)</l>
<l>select_shape (ConnectedRegions9, SelectedRegions8, 'area', 'and', 50, 1.0e6)</l>
<l>union1 (SelectedRegions8, RegionUnion2)</l>
<l>closing_circle (RegionUnion2, RegionClosing1, 10)</l>
<l>fill_up (RegionClosing1, RegionFillUp1)</l>
<c></c>
<l>* gen_contour_region_xld (RegionFillUp1, Contours1, 'border')</l>
<c></c>
<c></c>
<c>* 缺点：玻璃存在角度时偏差较大</c>
<l>* closing_rectangle1 (RegionFillUp1, RegionClosing, 3, 1000)</l>
<l>* gen_contour_region_xld (RegionClosing, Contours2, 'border')</l>
<c></c>
<l>* area_center (RegionClosing, Area2, Row3, Column3)</l>
<l>* region_features (RegionClosing, 'phi', Rad)</l>
<l>* RadV := deg(Rad)</l>
<l>* RadH := RadV - 90</l>
<l>* difference (RegionClosing, RegionFillUp1, RegionDifference)</l>
<c></c>
<l>* connection (RegionDifference, ConnectedRegions3)</l>
<l>* select_shape (ConnectedRegions3, SelectedRegions1, 'area', 'and', 1.0e3, 1.0e7)</l>
<l>* opening_rectangle1 (SelectedRegions1, RegionOpening, 200, 1)</l>
<l>* opening_rectangle1 (RegionOpening, RegionOpening1, 1, 300)</l>
<l>* count_obj (RegionOpening1, NumberMJ)</l>
<c></c>
<l>* gen_contour_region_xld (RegionOpening1, Contours1, 'border')</l>
<l>* fit_rectangle2_contour_xld (Contours1, 'regression', -1, 0, 0, 3, 2, Row4, Column4, Phi2, Length1, Length2, PointOrder)</l>
<l>* gen_rectangle2_contour_xld (Rectangle2, Row4, Column4, Phi2, Length1, Length2)</l>
<c>* 计算中心坐标</c>
<l>* area_center_points_xld (Rectangle2, Area4, Row6, Column6)</l>
<l>* gen_cross_contour_xld (Cross, Row6, Column6, 300, Phi2)</l>
<c></c>
<l>* X_MJ := []</l>
<l>* Y_MJ := []</l>
<l>* for I := 0 to NumberMJ - 1 by 1</l>
<l>*     if( abs(Rad - Phi2[I]) &gt; rad(5) )</l>
<l>*         X_MJ := [X_MJ, Length1[I]]</l>
<l>*         Y_MJ := [Y_MJ, Length2[I]]</l>
<l>*     else</l>
<l>*         X_MJ := [X_MJ, Length2[I]]</l>
<l>*         Y_MJ := [Y_MJ, Length1[I]]</l>
<l>*     endif</l>
<l>* endfor</l>
<c></c>
<c></c>
<c></c>
<c>* 方法二：筛选轮廓，生成最似矩形</c>
<l>shape_trans (RegionFillUp1, RegionTrans, 'convex')</l>
<l>gen_contour_region_xld (RegionTrans, Contours2, 'border')</l>
<l>area_center (RegionTrans, AreaGlass, RowGlassCentre, ColumnGlassCentre)</l>
<l>region_features (RegionTrans, 'phi', Rad)</l>
<l>RadV := deg(Rad)</l>
<l>RadH := RadV - 90</l>
<c></c>
<l>difference (RegionTrans, RegionFillUp1, RegionDifference)</l>
<l>opening_rectangle1 (RegionDifference, RegionOpening, 20, 1)</l>
<l>connection (RegionOpening, ConnectedRegions3)</l>
<l>select_shape (ConnectedRegions3, SelectedRegions1, 'area', 'and', 1.0e3, 1.0e7)</l>
<l>select_shape (SelectedRegions1, SelectedRegions2, 'height', 'and', 150, 99999)</l>
<l>count_obj (SelectedRegions2, NumberMJ)</l>
<l>sort_region (SelectedRegions2, SortedRegions, 'first_point', 'true', 'row')</l>
<c></c>
<c></c>
<c>* </c>
<l>X_MJ := []</l>
<l>Y_MJ := []</l>
<l>Rows_MJ := []</l>
<l>Columns_MJ := []</l>
<l>for I := 1 to NumberMJ by 1</l>
<l>    select_obj (SortedRegions, ObjectSelected3, I)</l>
<l>    gen_contour_region_xld (ObjectSelected3, Contours1, 'border')</l>
<l>    area_center (ObjectSelected3, AreaMJ, RowMJCentre, ColumnMJCentre)</l>
<c>    </c>
<c>*     轮廓分割，角度筛选，共线连接</c>
<l>    segment_contours_xld (Contours1, ContoursSplit1, 'lines', 1, 1, 2)</l>
<c>    </c>
<c>    * 竖边</c>
<l>    select_contours_xld (ContoursSplit1, SelectedContoursV, 'direction', rad(RadV - 5), rad(RadV + 5), -0.5, 0.5)</l>
<c>*     共线连接:合并具有相似方向的相邻直线轮廓</c>
<l>    union_collinear_contours_xld (SelectedContoursV, UnionContoursV, 50, 10, 10, rad(5), 'attr_keep')</l>
<l>    select_contours_xld (UnionContoursV, SelectedContoursV, 'contour_length', 40, 1.0e5, -0.5, 0.5)</l>
<l>    if (ColumnGlassCentre &gt; ColumnMJCentre)</l>
<l>        sort_contours_xld (SelectedContoursV, SortedContoursV, 'upper_left', 'true', 'column')</l>
<l>    else</l>
<l>        sort_contours_xld (SelectedContoursV, SortedContoursV, 'upper_left', 'false', 'column')</l>
<l>    endif</l>
<l>    select_obj (SortedContoursV, ContourV1, 1)</l>
<l>    select_obj (SortedContoursV, ContourV2, 2)</l>
<l>    concat_obj (ContourV1, ContourV2, ContourV)</l>
<c>    </c>
<c>    * 横边</c>
<l>    select_contours_xld (ContoursSplit1, SelectedContoursH, 'direction', rad(RadH - 5), rad(RadH + 5), -0.5, 0.5)</l>
<l>    union_collinear_contours_xld (SelectedContoursH, UnionContoursH, 50, 10, 10, rad(5), 'attr_keep')</l>
<l>    select_contours_xld (UnionContoursH, SelectedContoursH, 'contour_length', 100, 1.0e5, -0.5, 0.5)</l>
<c>    </c>
<c>    </c>
<l>    concat_obj (ContourV, SelectedContoursH, ObjectsConcat)</l>
<c>    *合并终点连接在一起的轮廓</c>
<l>    union_adjacent_contours_xld (ObjectsConcat, UnionContours1, 500, 1, 'attr_keep')</l>
<c>    </c>
<l>*     union2_closed_contours_xld (UnionContours1, ObjectsConcat, ContoursUnion)</l>
<l>    fit_rectangle2_contour_xld (UnionContours1, 'regression', -1, 0, 0, 3, 2, Row8, Column8, Phi4, Length13, Length23, PointOrder1)</l>
<l>    gen_rectangle2_contour_xld (Rectangle4, Row8, Column8, Phi4, Length13, Length23)</l>
<c>    </c>
<l>    if( abs(abs(Rad) - abs(Phi4)) &gt; rad(5) )</l>
<l>        X_MJ := [X_MJ, Length13 * 2]</l>
<l>        Y_MJ := [Y_MJ, Length23 * 2]</l>
<l>    else</l>
<l>        X_MJ := [X_MJ, Length23 * 2]</l>
<l>        Y_MJ := [Y_MJ, Length13 * 2]</l>
<l>    endif</l>
<c>    </c>
<l>    area_center_points_xld (Rectangle4, Area2, Row3, Column3)</l>
<c>    </c>
<l>    Rows_MJ := [Rows_MJ, Row3]</l>
<l>    Columns_MJ := [Columns_MJ, Column3]</l>
<l>endfor</l>
<l>gen_cross_contour_xld (Cross_MJ, Rows_MJ, Columns_MJ, 300, 0)</l>
<c>* 门夹几何中心：(Rows_MJ, Columns_MJ)</c>
<c>* 尺寸：X_MJ，Y_MJ</c>
<c></c>
<l>segment_contours_xld (Contours2, ContoursSplit2, 'lines_circles', 5, 4, 2)</l>
<l>select_contours_xld (ContoursSplit2, SelectedContours, 'direction', rad(RadH - 5), rad(RadH + 5), -0.5, 0.5)</l>
<l>union_collinear_contours_xld (SelectedContours, UnionContours1, 50, 10, 10, rad(5), 'attr_keep')</l>
<l>sort_contours_xld (UnionContours1, SortedFrameContoursH, 'upper_left', 'true', 'row')</l>
<l>select_obj (SortedFrameContoursH, ObjectSelectedTop, 1)</l>
<l>select_obj (SortedFrameContoursH, ObjectSelectedBtm, 2)</l>
<c></c>
<l>select_contours_xld (ContoursSplit2, SelectedContours, 'direction', rad(RadV - 5), rad(RadV + 5), -0.5, 0.5)</l>
<l>union_collinear_contours_xld (SelectedContours, UnionContours2, 50, 10, 10, rad(5), 'attr_keep')</l>
<l>sort_contours_xld (UnionContours2, SortedFrameContoursV, 'upper_left', 'true', 'column')</l>
<l>select_obj (SortedFrameContoursV, ObjectSelectedLeft, 1)</l>
<l>select_obj (SortedFrameContoursV, ObjectSelectedRight, 2)</l>
<l>fit_rectangle2_contour_xld (Contours2, 'regression', -1, 0, 0, 3, 2, Row4, Column4, Phi3, Length12, Length22, PointOrder)</l>
<l>gen_rectangle2_contour_xld (Rectangle2, Row4, Column4, Phi3, Length12, Length22)</l>
<l>DX_MJ := []</l>
<l>DY_MJ := []</l>
<l>for I := 0 to NumberMJ - 1 by 1</l>
<l>    distance_pc (ObjectSelectedTop, Rows_MJ[I], Columns_MJ[I], DistanceMinT, DistanceMax)</l>
<l>    distance_pc (ObjectSelectedBtm, Rows_MJ[I], Columns_MJ[I], DistanceMinB, DistanceMax)</l>
<l>    distance_pc (ObjectSelectedLeft, Rows_MJ[I], Columns_MJ[I], DistanceMinL, DistanceMax)</l>
<l>    distance_pc (ObjectSelectedRight, Rows_MJ[I], Columns_MJ[I], DistanceMinR, DistanceMax)</l>
<l>    if(DistanceMinT &lt; DistanceMinB)</l>
<l>        DY_MJ := [DY_MJ, DistanceMinT]</l>
<l>    else</l>
<l>        DY_MJ := [DY_MJ, DistanceMinB]</l>
<l>    endif</l>
<l>    if(DistanceMinL &lt; DistanceMinR)</l>
<l>        DX_MJ := [DX_MJ, DistanceMinL]</l>
<l>    else</l>
<l>        DX_MJ := [DX_MJ, DistanceMinR]</l>
<l>    endif</l>
<l>endfor</l>
<c></c>
<c></c>
<l>* stop()</l>
<c></c>
<c></c>
<c></c>
<c></c>
<c></c>
<c>***外围轮廓提取************** </c>
<l>opening_circle (TransformedRegion, RegionContour, 3.5)</l>
<l>GlassOutline:=RegionContour</l>
<l>region_features (RegionfullTrans, 'column1', Regionfullcolumn1)</l>
<l>region_features (RegionfullTrans, 'column2', Regionfullcolumn2)</l>
<l>height_width_ratio (RegionfullTrans, HeightRegionfull, WidthRegionfull, RatioRegionfull)</l>
<l>region_features (RegionfullTrans, 'row1', row1_Regionfull)</l>
<l>region_features (RegionfullTrans, 'row2', row2_Regionfull)</l>
<l>num:=HeightRegionfull/10</l>
<l>width_Regionfull:=[]</l>
<l>for i := 1 to 9 by 1</l>
<l>    gen_region_line (RegionLinesV, num*i+row1_Regionfull, 0, num*i+row1_Regionfull, Width_Image)</l>
<l>    intersection (RegionLinesV, RegionfullTrans, RegionIntersectionV)</l>
<l>    region_features (RegionIntersectionV, 'area', Value)</l>
<l>    width_Regionfull:=[width_Regionfull,Value]</l>
<c>    </c>
<l>endfor</l>
<l>tuple_length (width_Regionfull, LengthLinesV)</l>
<l>tuple_mean (width_Regionfull, width_Mean)</l>
<c></c>
<c></c>
<l>region_features (RegionfullTrans, 'column1', column1_Regionfull)</l>
<l>numW:=WidthRegionfull/10</l>
<l>height_Regionfull:=[]</l>
<l>for i := 1 to 9 by 1</l>
<l>    gen_region_line (RegionLinesH, 0, numW*i+column1_Regionfull, row2_Regionfull+1000, numW*i+column1_Regionfull)</l>
<l>    intersection (RegionLinesH, RegionfullTrans, RegionIntersectionH)</l>
<l>    region_features (RegionIntersectionH, 'area', Value)</l>
<l>    height_Regionfull:=[height_Regionfull,Value]</l>
<c>    </c>
<l>endfor</l>
<l>tuple_length (height_Regionfull, LengthLinesH)</l>
<l>tuple_mean (height_Regionfull, height_Mean)</l>
<c></c>
<c></c>
<l>Cam1pixValue:=0     </l>
<l>Cam2pixValue:=0</l>
<l>cam1pix:=Cam1Width-Regionfullcolumn1</l>
<l>if(cam1pix&lt;0)</l>
<l>   cam1pix:=0 </l>
<l>   cam2pix:=width_Mean</l>
<l>   Cam2pixValue:=(2*Cam2pixSetValue+KxCam2*(Regionfullcolumn1-Cam1Width)+KxCam2*(Regionfullcolumn2-Cam1Width))/2.000000 </l>
<l>else</l>
<l>    if(cam1pix&gt;width_Mean)</l>
<l>        cam1pix:=width_Mean</l>
<l>        cam2pix:=0</l>
<l>        Cam1pixValue:=Cam1pixSetValue+(KxCam1*(Regionfullcolumn1+Regionfullcolumn2))/2.000000              </l>
<l>    else        </l>
<l>        cam2pix:=width_Mean-cam1pix</l>
<l>        Cam1pixValue:=Cam1pixSetValue+(KxCam1*(Regionfullcolumn1)+KxCam1*Cam1Width)/2.000000</l>
<l>        Cam2pixValue:=Cam2pixSetValue+(KxCam2*(Regionfullcolumn2-Cam1Width))/2.000000       </l>
<l>    endif</l>
<l>endif</l>
<c></c>
<c></c>
<l>shape_trans (RegionfullTrans, RegionTrans, 'convex')</l>
<c></c>
<l>gen_contour_region_xld (RegionTrans, Contours, 'border')</l>
<l>segment_contours_xld (Contours, ContoursSplit, 'lines_circles', 5, 4, 2)</l>
<l>union_collinear_contours_xld (ContoursSplit, UnionContours, 10, 1, 10, 0.5, 'attr_keep')</l>
<l>elliptic_axis_xld (UnionContours, Ra, Rb, Phi)</l>
<l>fit_line_contour_xld (UnionContours, 'tukey', -1, 0, 5, 2, RowBegin, ColBegin, RowEnd, ColEnd, Nr, Nc, Dist)</l>
<l>gen_region_line (RegionLines, RowBegin, ColBegin, RowEnd,ColEnd)  </l>
<c>*水平线</c>
<l>select_shape (RegionLines, RegionLinesVS, 'ratio', 'and', 0, 0.01)  </l>
<l>union1 (RegionLinesVS, RegionUnionVS1)</l>
<l>closing_circle (RegionUnionVS1, RegionClosingVS1, 10.5)</l>
<l>connection (RegionClosingVS1, RegionLinesVS)</l>
<l>select_shape (RegionLinesVS, RegionLinesVS, 'area', 'and', 100, 999999999)</l>
<l>count_obj (RegionLinesVS, NumberVer)</l>
<l>if(NumberVer&gt;0) </l>
<l>   region_features (RegionLinesVS, 'orientation', ValueOriV)</l>
<l>   region_features (RegionLinesVS, 'row', rowOriV)</l>
<l>    gen_empty_obj (Contours11X)</l>
<l>     gen_empty_obj (Contours12X)</l>
<c>   ***上侧边缘提取</c>
<l>   c:=(((ValueOriV[&gt;]3.1 and ValueOriV[&lt;]3.17) or (ValueOriV[&lt;]0.05 and ValueOriV[&gt;]-0.03)) and rowOriV[&lt;]RowPanel)</l>
<l>   d:=find(c,1)</l>
<l>   if(d!=-1)</l>
<l>     select_obj (RegionLinesVS, RegionLinesVSelected, d+1)</l>
<l>     select_shape_std (RegionLinesVSelected, RegionLinesVSelectedstd, 'max_area', 70)</l>
<l>     gen_contour_region_xld (RegionLinesVSelectedstd, LinesVContours, 'border') </l>
<l>     count_obj (LinesVContours, NumberVContours)</l>
<l>    x1:=0</l>
<l>       if(NumberVContours&gt;0)          </l>
<l>            Contours11X:=LinesVContours</l>
<l>            elliptic_axis_xld (Contours11X, Ra1, Rb1, Phi11X)</l>
<l>            x1:=1</l>
<l>       endif</l>
<c>      </c>
<l>   endif</l>
<l>   region_features (RegionLinesVSelectedstd, 'phi', Value1)</l>
<c>   </c>
<l>   tuple_deg (Value1, Deg)</l>
<c>      ***下侧边缘提取</c>
<l>   c:=(((ValueOriV[&gt;]3.1 and ValueOriV[&lt;]3.17) or (ValueOriV[&lt;]0.05 and ValueOriV[&gt;]-0.03)) and rowOriV[&gt;]RowPanel)</l>
<l>   d:=find(c,1)</l>
<l>   if(d!=-1)</l>
<l>     select_obj (RegionLinesVS, RegionLinesVSelected, d+1)</l>
<l>     select_shape_std (RegionLinesVSelected, RegionLinesVSelectedstd, 'max_area', 70)</l>
<l>     gen_contour_region_xld (RegionLinesVSelectedstd, LinesVContours, 'border') </l>
<l>     count_obj (LinesVContours, NumberVContours)</l>
<l>       x2:=0</l>
<l>       if(NumberVContours&gt;0)          </l>
<l>            Contours12X:=LinesVContours</l>
<l>            elliptic_axis_xld (Contours12X, Ra1, Rb1, Phi12X)</l>
<l>            x2:=1</l>
<l>       endif</l>
<c>      </c>
<l>   endif</l>
<l>       if(x1=1 and x2=1)  </l>
<l>        phiX:=Phi12X+Phi11X</l>
<l>        tuple_abs (phiX, Abs)</l>
<l>        distance_cc_min (Contours11X, Contours12X, 'fast_point_to_segment', DistanceHMin)</l>
<l>        GlassHeight:=DistanceHMin*pixValue</l>
<l>       else</l>
<l>         GlassHeight:=0  </l>
<l>       endif</l>
<l>       GlassHeight:=height_Mean*pixValue</l>
<l>endif</l>
<c></c>
<c></c>
<c>   *竖线</c>
<l>   select_shape (RegionLines, RegionLinesHS, 'ratio', 'and', 100, 999999999)  </l>
<l>union1 (RegionLinesHS, RegionLinesHS1)</l>
<l>closing_circle (RegionLinesHS1, RegionClosingHS1, 10.5)</l>
<l>connection (RegionClosingHS1, RegionLinesHS2)</l>
<l>select_shape (RegionLinesHS2, RegionLinesHSelected, 'area', 'and', 100, 999999999)</l>
<c></c>
<l>   count_obj (RegionLinesHSelected, NumberHor)</l>
<l>if(NumberHor&gt;0)    </l>
<l>   region_features (RegionLinesHSelected, 'orientation', ValueOriH)</l>
<l>   region_features (RegionLinesHSelected, 'column', columnOriH)</l>
<l>   gen_empty_obj (Contours11Y)</l>
<l>   gen_empty_obj (Contours12Y)</l>
<c>   ****右侧边缘提取</c>
<l>   c:=(((ValueOriH[&gt;]1.54 and ValueOriH[&lt;]1.6) or (ValueOriH[&lt;]-1.54 and ValueOriH[&gt;]-1.6)) and columnOriH[&gt;]ColumnPanel)</l>
<l>   x3:=0</l>
<l>   d:=find(c,1)</l>
<l>   if(d!=-1)</l>
<l>        select_obj (RegionLinesHSelected, RegionLinesHSelected1, d+1)</l>
<l>        count_obj (RegionLinesHSelected1, NumberLinesH)</l>
<c>        </c>
<l>            select_shape_std (RegionLinesHSelected1, SelectedLinesHstd, 'max_area', 70)</l>
<l>            gen_contour_region_xld (SelectedLinesHstd, Contours11Y, 'border')</l>
<l>            x3:=1</l>
<l>   endif</l>
<c>       ****左侧边缘提取</c>
<l>   c:=(((ValueOriH[&gt;]1.54 and ValueOriH[&lt;]1.6) or (ValueOriH[&lt;]-1.54 and ValueOriH[&gt;]-1.6)) and columnOriH[&lt;]ColumnPanel)</l>
<l>   d:=find(c,1)</l>
<l>   x4:=0</l>
<l>   if(d!=-1)</l>
<l>        select_obj (RegionLinesHSelected, RegionLinesHSelected2, d+1)</l>
<l>        count_obj (RegionLinesHSelected2, NumberLinesH)</l>
<c>        </c>
<l>            select_shape_std (RegionLinesHSelected2, SelectedLinesHstd, 'max_area', 70)</l>
<l>            gen_contour_region_xld (SelectedLinesHstd, Contours12Y, 'border')</l>
<l>            x4:=1       </l>
<l>   endif</l>
<c>  </c>
<l>   if(x3=1 and x4=1)</l>
<l>   distance_cc_min (Contours11Y, Contours12Y, 'point_to_point', DistanceWMin)</l>
<l>        GlassWidth:=DistanceWMin*pixValue</l>
<l>   else</l>
<l>      GlassWidth:=0 </l>
<l>   endif</l>
<l>   GlassWidth:=cam1pix*Cam1pixValue+cam2pix*Cam2pixValue</l>
<l>endif</l>
<c></c>
<c>****测量标准***************************************</c>
<l>GlassCriterionW:=10</l>
<l>GlassCriterionH:=10</l>
<l>GlassErrRange:=1</l>
<l>GlassOK:='OK'</l>
<c>****测量标准***************************************</c>
<c></c>
<l>siyienable:=1</l>
<l>if(siyienable=1)</l>
<c>***************************************siyin门夹匹配开始***************************</c>
<l>threshold (ImageAffineTrans, Region, 30, 255)</l>
<l>fill_up (Region, RegionFillUp)</l>
<l>erosion_circle (RegionFillUp, RegionErosion, 50.5)</l>
<l>connection (RegionErosion, ConnectedRegions)</l>
<l>select_shape_std (ConnectedRegions, SelectedRegions, 'max_area', 70)</l>
<l>reduce_domain (ImageAffineTrans4, SelectedRegions, ImageReduced4)</l>
<l>threshold (ImageReduced4, RegionThresh, 0, 70)</l>
<l>connection (RegionThresh, ConnectedRegions1)</l>
<c></c>
<l>select_shape (ConnectedRegions1, SelectedRegions4, 'area', 'and', 5, 9999)</l>
<l>union1 (SelectedRegions4, RegionUnion)</l>
<l>closing_circle (RegionUnion, RegionClosing3, 80.5)</l>
<l>connection (RegionClosing3, ConnectedRegions2)</l>
<l>select_shape (ConnectedRegions2, SelectedRegions7, 'area', 'and', 10000, 99999999)</l>
<l>count_obj (SelectedRegions7, Number)</l>
<c>    </c>
<l>for Index := 1 to Number by 1</l>
<l>    select_obj (SelectedRegions7, ObjectSelected1, Index)</l>
<l>    intersection (ObjectSelected1, SelectedRegions4, RegionIntersection)</l>
<l>    connection (RegionIntersection, ConnectedRegions7)</l>
<l>    count_obj (ConnectedRegions7, Number7)  </l>
<l>    compactness (ObjectSelected1, Compactness)</l>
<l>    if(Number7&gt;2 and Compactness&lt;6)</l>
<l>        smallest_rectangle1 (ObjectSelected1, RowObj11, ColumnObj11, RowObj12, ColumnObj12)</l>
<l>        gen_rectangle1 (RectangleObj1, RowObj11, ColumnObj11, RowObj12, ColumnObj12)</l>
<l>        area_center (RectangleObj1, AreaObj1, RowSiyin, ColumnSiyin)</l>
<l>        height_width_ratio (RectangleObj1, HeightSiyin, WidthSiyin, Ratio)</l>
<l>        if(ColumnSiyin &gt; 600)</l>
<l>            crop_part (ImageAffineTrans4, ImagePart1, RowSiyin-300, ColumnSiyin-600, 1200, 600)</l>
<l>        else</l>
<l>           crop_part (ImageAffineTrans4, ImagePart1, RowSiyin-300, 0, 1200, 600) </l>
<l>        endif</l>
<l>        threshold (ImagePart1, Region4, 0, 255)</l>
<l>        concat_obj (SiYin, ImagePart1, SiYin)</l>
<c> </c>
<l> *       dyn_threshold (ImagePart3, ImageMean, RegionDynThresh, 40, 'dark')</l>
<l>        threshold (ImagePart1, Region3, 0, 70)</l>
<l>        closing_circle (Region3, RegionClosing, 80.5)</l>
<l>        connection (RegionClosing, ConnectedRegions8)</l>
<l>        select_shape_std (ConnectedRegions8, SelectedRegions5, 'max_area', 70)</l>
<l>        intersection (Region3, SelectedRegions5, RegionIntersection2)</l>
<l>        connection (RegionIntersection2, ConnectedRegions5)</l>
<l>        select_shape (ConnectedRegions5, SelectedRegions9, 'area', 'and', 5, 99999)</l>
<c>        </c>
<l>        union1 (SelectedRegions9, RegionUnion3)</l>
<l>        difference (Region4, RegionUnion3, RegionDifference2)</l>
<l>        paint_region (RegionDifference2, ImagePart1, rImage, 155, 'fill')</l>
<l>        concat_obj (siyinrImage, rImage, siyinrImage)</l>
<l>        siyinRowM:=[siyinRowM,RowSiyin]</l>
<l>        siyinColumnM:=[siyinColumnM,ColumnSiyin]</l>
<l>        siyinWidthM:=[siyinWidthM,WidthSiyin]</l>
<l>        siyinHeightM:=[siyinHeightM,HeightSiyin]</l>
<l>*         count:=40+Index+1</l>
<l>*         write_image (rImage, 'png', 0, 'D:/HalconFunction/siyinMoBan/'+count+'.bmp')</l>
<l>    endif</l>
<l>endfor</l>
<c></c>
<l>count_obj (SelectedRegionsMJ, NumberMJ)</l>
<l>for Index6 := 1 to NumberMJ by 1</l>
<l>    select_obj (SelectedRegionsMJ, ObjectSelected2, Index6)</l>
<l>    smallest_rectangle1 (ObjectSelected2, Row13, Column13, Row21, Column21)</l>
<l>    gen_rectangle1 (Rectangle1, Row13, Column13, Row21, Column21)</l>
<l>    area_center (Rectangle1, Area3, Row5, Column5)</l>
<c>    </c>
<l>    move_region (ObjectSelected2, RegionMovedObj, Row5/ScaleFactorY-Row5, 0)</l>
<c></c>
<l>    paint_region (RegionMovedObj, ImageAffineTrans, ImageResult2, 255, 'fill')</l>
<l>    if(Column5&gt;600)</l>
<l>crop_part (ImageResult2, ImagePart2, Row5/ScaleFactorY-400, Column5-600, 1200, 800)</l>
<l>    else</l>
<l>  crop_part (ImageResult2, ImagePart2, Row5/ScaleFactorY-400, 0, 1200, 800)      </l>
<l>    endif</l>
<l>threshold (ImagePart2, Region5, 0, 254)</l>
<l>paint_region (Region5, ImagePart2, ImageResult, 0, 'fill')</l>
<l>concat_obj (menjiarImage, ImageResult, menjiarImage)</l>
<l>*     count:=Index6+40    </l>
<l>*     write_image (ImageResult, 'png', 0, 'D:/HalconFunction/menjiaMoBan/'+count+'.bmp')</l>
<l>endfor</l>
<c>           </c>
<l>list_files ('D:/HalconFunction/siyinMoBan', 'files', Files)</l>
<l>Selection:=regexp_select(Files,'')</l>
<l>for Index4 := 0 to |Selection|-1 by 1</l>
<l>        read_image (ModelImage, Selection[Index4])</l>
<l>        get_image_size (ModelImage, Width, Height)</l>
<c>       </c>
<l>        get_model_region (ModelImage, RegionROI, ImageReduced, ModelImage)</l>
<l>        area_center (RegionROI, Area, RowModel, ColumnModel)</l>
<l>        dev_set_draw ('fill')</l>
<l>        dev_set_color ('green')</l>
<c>        * </c>
<c>        * Create a model for shape-based-matching.</c>
<l>        dev_display (RegionROI)</l>
<c>        * </c>
<c>        * Create a model for shape-based-matching.</c>
<l>        create_generic_shape_model (ModelID)</l>
<l>        set_generic_shape_model_param (ModelID, 'iso_scale_min', 0.6)</l>
<l>        set_generic_shape_model_param (ModelID, 'iso_scale_max', 1.02)</l>
<l>        train_generic_shape_model (ImageReduced, ModelID)</l>
<l>        set_generic_shape_model_param (ModelID, 'min_score', 0.3)</l>
<l>        set_generic_shape_model_param (ModelID, 'num_matches', 1)</l>
<l>        set_generic_shape_model_param (ModelID, 'max_overlap', 0)</l>
<l>        set_generic_shape_model_param (ModelID, 'pyramid_level_lowest', 3)</l>
<c>        * </c>
<c>        * Create a variation model for print inspection.</c>
<l>        create_variation_model (Width, Height, 'byte', 'direct', VariationID)</l>
<c>        * Generate the variation image.</c>
<l>        sobel_amp (ModelImage, VarImage, 'sum_abs', 3)</l>
<l>        prepare_direct_variation_model (ModelImage, VarImage, VariationID, [20, 25], [1.6, 1.6])</l>
<c>        * </c>
<c>        * Get the gray value range of the variation model to compensate</c>
<c>        * for the illumination changes.</c>
<l>        get_grayval_range (ModelImage, RegionROI, RegionForeground, RegionBackground, BackgroundGVModel, ForegroundGVModel)                      </l>
<l>        count_obj (siyinrImage, NumberSiyin)</l>
<l>        gen_empty_obj (siyinrImageM)</l>
<l>        siyinRowM1:=[]</l>
<l>        siyinColumNM1:=[]</l>
<l>        siyinWidthM1:=[]</l>
<l>        siyinHeightM1:=[]</l>
<l>        if(NumberSiyin&gt;0)</l>
<l>            for Index5 := 1 to NumberSiyin by 1</l>
<l>                select_obj (siyinrImage, ObjectSelectedr, Index5)    </l>
<l>                    InspectCap (ObjectSelectedr, RegionROI, RegionBackground,ModelID, VariationID, RowModel, ColumnModel, BackgroundGVModel, ForegroundGVModel, BackgroundGVal, ForegroundGVal, OKsiyin, NumMatchResult)</l>
<l>                      if(NumMatchResult&gt;0)</l>
<l>                        concat_obj (SiYinDefect, ObjectSelectedr, SiYinDefect)</l>
<l>                         typeSiYin:=[typeSiYin,'丝印']            </l>
<c>                         </c>
<l>                        if(OKsiyin=1)</l>
<l>                           SiYinOK:=[SiYinOK,'OK']  </l>
<l>                        else</l>
<l>                           SiYinOK:=[SiYinOK,'NG']   </l>
<l>                        endif</l>
<l>                          siyinRow:=[siyinRow,siyinRowM[Index5-1]]</l>
<l>        siyinColumn:=[siyinColumn,siyinColumnM[Index5-1]]</l>
<l>        siyinWidth:=[siyinWidth,siyinWidthM[Index5-1]]</l>
<l>        siyinHeight:=[siyinHeight,siyinHeightM[Index5-1]] </l>
<l>                      else</l>
<l>                          concat_obj (siyinrImageM, ObjectSelectedr, siyinrImageM)</l>
<l>                           siyinRowM1:=[siyinRowM1,siyinRowM[Index5-1]]</l>
<l>        siyinColumNM1:=[siyinColumNM1,siyinColumnM[Index5-1]]</l>
<l>        siyinWidthM1:=[siyinWidthM1,siyinWidthM[Index5-1]]</l>
<l>        siyinHeightM1:=[siyinHeightM1,siyinHeightM[Index5-1]] </l>
<l>                      endif</l>
<l>            endfor</l>
<l>            gen_empty_obj (siyinrImage)</l>
<l>            siyinrImage:=siyinrImageM</l>
<l>            siyinRowM:=siyinRowM1</l>
<l>        siyinColumnM:=siyinColumNM1</l>
<l>        siyinWidthM:=siyinWidthM1</l>
<l>        siyinHeightM:=siyinHeightM1</l>
<l>        endif</l>
<c>                  </c>
<l>endfor</l>
<c></c>
<c></c>
<c>       </c>
<l>list_files ('D:/HalconFunction/menjiaMoBan', 'files', Files)</l>
<l>Selection:=regexp_select(Files,'')</l>
<l>for Index6 := 0 to |Selection|-1 by 1</l>
<l>        read_image (ModelImage, Selection[Index6])</l>
<l>        get_image_size (ModelImage, Width, Height)</l>
<c>        </c>
<l>        get_modelMJ_region (ModelImage, RegionROI, ImageReduced, ModelImage)</l>
<l>        area_center (RegionROI, Area, RowModel, ColumnModel)</l>
<l>        dev_set_draw ('fill')</l>
<l>        dev_set_color ('green')</l>
<c>        * </c>
<c>        * Create a model for shape-based-matching.</c>
<l>        dev_display (RegionROI)</l>
<c>        * </c>
<c>        * Create a model for shape-based-matching.</c>
<l>        create_generic_shape_model (ModelID)</l>
<l>        set_generic_shape_model_param (ModelID, 'iso_scale_min', 0.6)</l>
<l>        set_generic_shape_model_param (ModelID, 'iso_scale_max', 1.02)</l>
<l>        train_generic_shape_model (ImageReduced, ModelID)</l>
<l>        set_generic_shape_model_param (ModelID, 'min_score', 0.3)</l>
<l>        set_generic_shape_model_param (ModelID, 'num_matches', 1)</l>
<l>        set_generic_shape_model_param (ModelID, 'max_overlap', 0)</l>
<l>        set_generic_shape_model_param (ModelID, 'pyramid_level_lowest', 3)</l>
<c>        * </c>
<c>        * Create a variation model for print inspection.</c>
<l>        create_variation_model (Width, Height, 'byte', 'direct', VariationID)</l>
<c>        * Generate the variation image.</c>
<l>        sobel_amp (ModelImage, VarImage, 'sum_abs', 3)</l>
<l>        prepare_direct_variation_model (ModelImage, VarImage, VariationID, [20, 25], [1.6, 1.6])</l>
<c>        * </c>
<c>        * Get the gray value range of the variation model to compensate</c>
<c>        * for the illumination changes.</c>
<l>        get_grayval_range (ModelImage, RegionROI, RegionForeground, RegionBackground, BackgroundGVModel, ForegroundGVModel)                      </l>
<l>        count_obj (menjiarImage, Number5)</l>
<l>        gen_empty_obj (menjiarImageM)</l>
<l>        for Index15 := 1 to Number5 by 1</l>
<l>            select_obj (menjiarImage, ObjectSelectedr, Index15)</l>
<c></c>
<l>            inspectMJ_cap (ObjectSelectedr, RegionROI, RegionBackground, ModelID, VariationID, RowModel, ColumnModel, BackgroundGVModel, ForegroundGVModel, BackgroundGVal, ForegroundGVal, OKmenjia, NumMatchResult)</l>
<l>                  if(NumMatchResult&gt;0) </l>
<l>                    if(OKmenjia=1)</l>
<l>                       MJOK:=[MJOK,'OK']  </l>
<l>                    else</l>
<l>                       MJOK:=[MJOK,'NG']   </l>
<l>                    endif</l>
<l>                    select_obj (SelectedRegionsMJ, ObjectSelectedMJ, Index15)</l>
<l>                    concat_obj (RegionMJ, ObjectSelectedMJ, RegionMJ)</l>
<l>                    else</l>
<l>                        concat_obj (menjiarImageM, ObjectSelectedr, menjiarImageM)</l>
<l>                  endif</l>
<l>        endfor</l>
<c>        </c>
<l>        gen_empty_obj (menjiarImage)</l>
<l>      menjiarImage:=menjiarImageM</l>
<c>                  </c>
<l>endfor</l>
<c></c>
<l>endif</l>
<c></c>
<c></c>
<c>***************************************siyin门夹匹配结束***************************</c>
<l>region_features (SelectedHolesT, 'roundness', RegionsRoundness)</l>
<l>c:=(RegionsRoundness[&gt;]0.8)</l>
<l>d:=find(c,1)</l>
<l>if(d!=-1)</l>
<l>select_obj (SelectedHolesT, SelectedRegionsHoles, d+1)</l>
<l>count_obj (SelectedRegionsHoles, NumberH)</l>
<c></c>
<l>tuple_gen_const (NumberH, '孔', HolesTuple)</l>
<c> </c>
<c></c>
<l>count_obj (RegionMJ, NumberMJ)</l>
<l>tuple_gen_const (NumberMJ, '门夹', MenJiaTuple)</l>
<l>tuple_concat (HolesTuple, MenJiaTuple, Type)</l>
<c></c>
<l>concat_obj (SelectedRegionsHoles, RegionMJ, ObjectsConcatQK)</l>
<l>endif</l>
<c></c>
<l>count_obj (ObjectsConcatQK, NumberQK)</l>
<l>if(NumberQK&gt;0)  </l>
<l>smallest_rectangle1 (ObjectsConcatQK, Row11, Column11, Row12, Column12)</l>
<l>gen_rectangle1 (Rectangle, Row11/ScaleFactorY-50, Column11-50, Row12/ScaleFactorY+50, Column12+50)</l>
<l>  for Index2 := 1 to NumberQK by 1</l>
<l>    select_obj (Rectangle, ObjectSelected, Index2)</l>
<l>    reduce_domain (ImageAffineTrans, ObjectSelected, ImageReduced)</l>
<l>    crop_domain (ImageReduced, ImagePart)</l>
<l>    concat_obj (QKImage, ImagePart, QKImage)</l>
<l>  endfor</l>
<c></c>
<c>*****</c>
<l>area_center (ObjectsConcatQK, AreaQK, RowQK1, ColumnQK1)</l>
<c></c>
<l>smallest_rectangle2 (ObjectsConcatQK, RowQK, ColumnQK, Phi2, Length1, Length2)</l>
<c></c>
<c></c>
<c></c>
<c></c>
<c></c>
<l>* region_features (SelectedRegionsHoles, 'width', width_Holes)</l>
<l>* region_features (SelectedRegionsHoles, 'height', height_Holes)</l>
<l>region_features (TransSelectedRegionsTL, 'height', width_Holes)</l>
<l>region_features (TransSelectedRegionsTL, 'height', height_Holes)</l>
<l>* region_features (TransSelectedRegionsTL, 'rect2_len1', HolesSizeM)</l>
<l>* region_features (TransSelectedRegionsTL, 'rect2_len1', height_Holes)</l>
<l>* width_Holes:=2*HolesSizeM</l>
<l>* height_Holes:=2*HolesSizeM</l>
<l>* dev_display(SelectedRegionsHoles)</l>
<c></c>
<c></c>
<l>QKWidth:=[QKWidth,width_Holes*pixValue]</l>
<l>QKHeight:=[QKHeight,height_Holes*pixValue]</l>
<c></c>
<c></c>
<l>region_features (RegionMJ, 'width', width_MJ)</l>
<l>region_features (RegionMJ, 'height', height_MJ)</l>
<l>K := 1.07883347</l>
<l>* QKWidth:=[QKWidth,width_MJ*pixValue]</l>
<l>* QKHeight:=[QKHeight,height_MJ*pixValue]</l>
<l>QKWidth:=[QKWidth,X_MJ*pixValue]</l>
<l>QKHeight:=[QKHeight,Y_MJ*pixValue  * K]</l>
<c></c>
<c>**水平方向距离</c>
<l>dis_min1:=[]</l>
<l>dis_min2:=[]</l>
<l>distance_pc (Contours11X, RowQK, ColumnQK, DistanceMin1, DistanceMax1)</l>
<l>distance_pc (Contours12X, RowQK, ColumnQK, DistanceMin2, DistanceMax2)</l>
<l>dis_min1:= DistanceMin1</l>
<l>dis_min2:= DistanceMin2</l>
<l>count:=|dis_min1|</l>
<l>dismin_horn:=[]</l>
<l>for Index1 := 1 to count by 1</l>
<l>    tuple_select (dis_min1, Index1-1, Selected1)</l>
<l>    tuple_select (dis_min2, Index1-1, Selected2)    </l>
<l>    tuple_min2 (Selected1, Selected2, Min2)  </l>
<l>    dismin_horn:=[dismin_horn,Min2]</l>
<l>endfor</l>
<l>DistanceHorizontal:=dismin_horn*pixValue</l>
<c>***dismin_horn水平距离结果</c>
<c></c>
<c></c>
<l>* count_obj (TransSelectedRegionsTL, LengthQK)</l>
<l>* TopDistance := DistanceMin1[0 : LengthQK - 1]</l>
<c></c>
<c>**SIYINX***</c>
<l>tuple_length (siyinRow, Length)</l>
<l>if(Length&gt;0)</l>
<l>dis_min1:=[]</l>
<l>dis_min2:=[]</l>
<l>distance_pc (Contours11X, siyinRow*ScaleFactorY, siyinColumn, DistanceMin1, DistanceMax1)</l>
<l>distance_pc (Contours12X, siyinRow*ScaleFactorY, siyinColumn, DistanceMin2, DistanceMax2)</l>
<l>dis_min1:= DistanceMin1</l>
<l>dis_min2:= DistanceMin2</l>
<l>count:=|dis_min1|</l>
<l>dismin_horn:=[]</l>
<l>for Index1 := 1 to count by 1</l>
<l>    tuple_select (dis_min1, Index1-1, Selected1)</l>
<l>    tuple_select (dis_min2, Index1-1, Selected2)    </l>
<l>    tuple_min2 (Selected1, Selected2, Min2) </l>
<l>    dismin_horn:=[dismin_horn,Min2]</l>
<l>endfor</l>
<l>SiYinDistanceHorizontal:=dismin_horn*pixValue</l>
<c></c>
<c></c>
<c>**SIYINY***</c>
<l>dis_min1:=[]</l>
<l>dis_min2:=[]</l>
<l>distance_pc (Contours11Y, siyinRow*ScaleFactorY, siyinColumn, DistanceMin1, DistanceMax1)</l>
<l>distance_pc (Contours12Y, siyinRow*ScaleFactorY, siyinColumn, DistanceMin2, DistanceMax2)</l>
<l>dis_min1:= DistanceMin1</l>
<l>dis_min2:= DistanceMin2</l>
<l>count:=|dis_min1|</l>
<l>dismin_horn:=[]</l>
<l>for Index1 := 1 to count by 1</l>
<l>    tuple_select (dis_min1, Index1-1, Selected1)</l>
<l>    tuple_select (dis_min2, Index1-1, Selected2)    </l>
<l>    tuple_min2 (Selected1, Selected2, Min2) </l>
<l>    dismin_horn:=[dismin_horn,Min2]</l>
<l>endfor</l>
<l>SiYinDistanceVertical:=dismin_horn*pixValue</l>
<c> </c>
<l>endif</l>
<c>**垂直方向距离</c>
<l>dis_min1:=[]</l>
<l>dis_min2:=[]</l>
<l>distance_pc (Contours11Y, RowQK, ColumnQK, DistanceMin1, DistanceMax1)</l>
<l>distance_pc (Contours12Y, RowQK, ColumnQK, DistanceMin2, DistanceMax2)</l>
<l>dis_min1:= DistanceMin1</l>
<l>dis_min2:= DistanceMin2</l>
<l>count:=|dis_min1|</l>
<l>dismin_ver:=[]</l>
<c></c>
<l>for Index1 := 1 to count by 1</l>
<l>    tuple_select (dis_min1, Index1-1, Selected1)</l>
<l>    tuple_select (dis_min2, Index1-1, Selected2)  </l>
<l>    tuple_min2 (Selected1, Selected2, Min2)</l>
<l>    dismin_ver:=[dismin_ver,Min2]  </l>
<l>endfor</l>
<l>DistanceVertical:=dismin_ver*pixValue</l>
<c>*****门夹边距值替换</c>
<l>mjcount:=|X_MJ|</l>
<l>if (mjcount&gt;0)</l>
<c>    ****边距Y******</c>
<l>    DHCount:=|DistanceVertical|</l>
<l>    tuple_select_range(DistanceVertical,0,DHCount-mjcount-1,ArraySelect) </l>
<l>    newDHmjDistance := X_MJ*pixValue/2</l>
<l>    tuple_concat(ArraySelect,newDHmjDistance,DistanceVertical)</l>
<c>    ****边距X******</c>
<l>    tuple_select_range(DistanceHorizontal,0,DHCount-mjcount-1,ArraySelect2)</l>
<l>    newmjDistanceHorizontal := DY_MJ * PixelAccuracyY</l>
<l>    tuple_concat(ArraySelect2,newmjDistanceHorizontal,DistanceHorizontal)</l>
<l>endif</l>
<c></c>
<l>endif</l>
<c>* // 定义缩小比例</c>
<l>ScaleFactor1X :=GlassWidth /(width_Mean+0.0000001)</l>
<l>ScaleFactor1Y :=GlassHeight /(height_Mean+0.0000001)</l>
<c></c>
<l>zoom_region (RegionMoved1, RegionZoom1, ScaleFactor1X, ScaleFactor1Y)</l>
<l>area_center (RegionZoom1, Area1, Row2, Column2)</l>
<c></c>
<l>vector_angle_to_rigid (Row2, Column2, 0, Column2, Row2, 1.5708, HomMat2D)</l>
<l>affine_trans_region (RegionZoom1, RegionAffineTrans1, HomMat2D, 'nearest_neighbor')</l>
<l>smallest_rectangle1 (RegionAffineTrans1, Row14, Column14, Row22, Column22)</l>
<l>move_region (RegionAffineTrans1, RegionMoved2, Row14-Row22, -Column14)</l>
<l>tuple_deg (1.5708, Deg1)</l>
<l>gen_contour_region_xld (RegionMoved2, GlassContours, 'border_holes')</l>
<c></c>
<l>Row_y:=[]</l>
<l>Col_x:=[]</l>
<l>count_obj (GlassContours, NumberContours)</l>
<l>for IndexContours := 1 to NumberContours by 1</l>
<l>    select_obj (GlassContours, ObjectContour, IndexContours)</l>
<l>    get_contour_xld (ObjectContour, Row_1, Col_1)</l>
<l>    Row_y:=[Row_y,Row_1]</l>
<l>    Col_x:=[Col_x,Col_1]</l>
<c>    </c>
<l>endfor</l>
<l>CriterionX:=10</l>
<l>CriterionY:=10</l>
<l>CriterionW:=10</l>
<l>CriterionH:=10</l>
<l>ErrRange:=1</l>
<l>for Index3 := 1 to NumberH by 1</l>
<l>    QKOK:=[QKOK,'OK']</l>
<l>endfor</l>
<c></c>
<c></c>
<l>QKOK:=[QKOK,MJOK]</l>
<c></c>
<c>*****dismin_ver垂直距离</c>
<l>concat_obj (QKImage, SiYinDefect, HolesImage)</l>
<c></c>
<l>concat_obj (SiYinDefect, rImage, SiYinDefect)</l>
<l>             Type:=[Type,typeSiYin]</l>
<l>             QKOK:=[QKOK,SiYinOK]</l>
<l>             DistanceHorizontal:=[DistanceHorizontal,SiYinDistanceHorizontal]</l>
<l>             DistanceVertical:=[DistanceVertical,SiYinDistanceVertical]</l>
<l>             QKWidth:=[QKWidth,siyinWidth*pixValuesiyin]</l>
<l>             QKHeight:=[QKHeight,siyinHeight*pixValue]</l>
<c>*****************************************************************************************************</c>
<l>tuple_length (siyinColumn, Length3)</l>
<l>if (Length3 !=0 )</l>
<l>      gen_region_points (Regionsiyin, siyinRow*ScaleFactorY, siyinColumn)</l>
<l>      concat_obj (ObjectsConcatQK, Regionsiyin, ObjectsConcatQK)</l>
<l>endif</l>
<c></c>
<l>move_region (ObjectsConcatQK, RegionMovedQK, -RowRegion1, -ColumnRegion1)</l>
<l>zoom_region (RegionMovedQK, RegionZoomQK, ScaleFactor1X, ScaleFactor1Y)</l>
<l>affine_trans_region (RegionZoomQK, RegionAffineTransQK, HomMat2D, 'nearest_neighbor')</l>
<l>move_region (RegionAffineTransQK, RegionMoved2QK, Row14-Row22, -Column14)        </l>
<l>area_center (RegionMoved2QK, Area1QK, Row2QK, Column2QK)</l>
<c></c>
<c></c>
<c></c>
<c></c>
<c>*************************收集数据******************************* </c>
<l>create_dict (ResultDictHoles)</l>
<l>set_dict_tuple (ResultDictHoles, 'GlassOK', GlassOK)</l>
<l>set_dict_tuple (ResultDictHoles, 'GlassHeight', GlassHeight)</l>
<l>set_dict_tuple (ResultDictHoles, 'GlassWidth', GlassWidth)</l>
<l>set_dict_tuple (ResultDictHoles, 'GlassAngle', GlassAngle)</l>
<l>set_dict_tuple (ResultDictHoles, 'Type', Type)</l>
<l>set_dict_tuple (ResultDictHoles, 'HolesOK', QKOK)</l>
<l>set_dict_tuple (ResultDictHoles, 'DistanceHorizontal', DistanceHorizontal)</l>
<l>set_dict_tuple (ResultDictHoles, 'DistanceVertical', DistanceVertical)</l>
<l>set_dict_tuple (ResultDictHoles, 'HolesWidth', QKWidth)</l>
<l>set_dict_tuple (ResultDictHoles, 'HolesHeight', QKHeight)</l>
<l>set_dict_tuple (ResultDictHoles, 'Col_x', Col_x)</l>
<l>set_dict_tuple (ResultDictHoles, 'Row_y', Row_y)</l>
<l>set_dict_tuple (ResultDictHoles, 'Column2QK',Column2QK)</l>
<l>set_dict_tuple (ResultDictHoles, 'Row2QK', Row2QK)</l>
<l>return ()</l>
<l>catch (Exception)</l>
<l>   create_dict (ResultDictHoles)</l>
<l>GlassHeight:=0</l>
<l>GlassWidth:=0</l>
<l>GlassAngle:=0</l>
<l>set_dict_tuple (ResultDictHoles, 'GlassHeight', GlassHeight)</l>
<l>set_dict_tuple (ResultDictHoles, 'GlassWidth', GlassWidth)</l>
<l>set_dict_tuple (ResultDictHoles, 'GlassAngle', GlassAngle)</l>
<l>endtry</l>
</body>
<docu id="ProcessHoles">
<parameters>
<parameter id="Cam1Width"/>
<parameter id="Cam1pixs"/>
<parameter id="DetectDict"/>
<parameter id="GlassContours"/>
<parameter id="HolesImage"/>
<parameter id="Image1"/>
<parameter id="Image2"/>
<parameter id="Image3"/>
<parameter id="Image4"/>
<parameter id="OutLineImage"/>
<parameter id="ResultDictHoles"/>
<parameter id="Tile2Column1"/>
</parameters>
</docu>
</procedure>
</hdevelop>
