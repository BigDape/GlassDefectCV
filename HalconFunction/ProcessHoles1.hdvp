<?xml version="1.0" encoding="UTF-8"?>
<hdevelop file_version="1.2" halcon_version="22.05.0.0">
<procedure name="ProcessHoles">
<interface>
<io>
<par name="Image1" base_type="iconic" dimension="0"/>
<par name="Image2" base_type="iconic" dimension="0"/>
<par name="Image3" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="OutLineImage" base_type="iconic" dimension="0"/>
<par name="HolesImage" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="DetectDict" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="ResultDictHoles" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>try</l>
<l>* set_system ('parallelize_operators', 'true')</l>
<l>dev_update_off ()</l>
<l>* dev_update_time ('off')</l>
<l>* dev_update_pc ('off')</l>
<l>* dev_update_var ('off')</l>
<l>dev_update_window ('off')</l>
<c>**********************初始化输出*****************************</c>
<l>dev_set_draw ('fill')</l>
<l>GlassOK:=[]</l>
<l>QKOK:=[]</l>
<l>gen_empty_obj (QKImage)</l>
<l>gen_empty_obj (TransformedRegion)</l>
<l>gen_empty_obj (OutLineImage)</l>
<l>gen_empty_obj(LinesVContours)</l>
<l>gen_empty_obj(LinesHContours)</l>
<l>gen_empty_obj(SelectedRegionsHoles)</l>
<l>gen_empty_obj(SelectedRegionsMJ)</l>
<l>gen_empty_obj(ObjectsConcatQK)</l>
<l>pixValue:=0.0958926</l>
<c></c>
<l>DistanceHorizontal:=[]</l>
<l>DistanceVertical:=[]</l>
<l>HolesHeight:=[]</l>
<l>HolesWidth:=[]</l>
<l>GlassWidth:=[]</l>
<l>GlassHeight:=[]</l>
<l>set_system ('clip_region', 'false')</l>
<c></c>
<c></c>
<l>get_image_size (Image3, Width, Height)</l>
<c></c>
<l>threshold (Image2, RegionFL, 20, 255)</l>
<l>opening_circle (RegionFL, RegionOpeningFL, 1.5)</l>
<l>closing_circle (RegionOpeningFL, RegionClosingFL, 30.5)</l>
<l>connection (RegionClosingFL, ConnectedRegionsFL)</l>
<l>select_shape_std (ConnectedRegionsFL, SelectedRegionsFL, 'max_area', 70)</l>
<l>region_features (SelectedRegionsFL, 'width', RegionsWidth)</l>
<l>erosion_circle (SelectedRegionsFL, RegionErosionFL, 20.5)</l>
<l>difference (SelectedRegionsFL, RegionErosionFL, RegionDifferenceFL)</l>
<l>opening_rectangle1 (RegionDifferenceFL, RegionOpening1FL, 30, 1)</l>
<l>connection (RegionOpening1FL, ConnectedRegions2FL)</l>
<l>select_shape (ConnectedRegions2FL, SelectedRegions1FL, 'width', 'and', 0.8*RegionsWidth, 2*RegionsWidth)</l>
<l>dilation_circle (SelectedRegions1FL, RegionDilationFL, 100.5)</l>
<c></c>
<c></c>
<c></c>
<l>threshold (Image1, RegionTL, 0, 20)</l>
<l>intersection (RegionDilationFL, RegionTL, RegionIntersectionFT)</l>
<l>connection (RegionIntersectionFT, ConnectedRegionsTL)</l>
<l>select_shape (ConnectedRegionsTL, SelectedRegionsTL, 'width', 'and', 0.8*RegionsWidth, 2*RegionsWidth)</l>
<l>union2 (SelectedRegionsTL, SelectedRegionsFL, RegionUnionFT)</l>
<l>union1 (RegionUnionFT, RegionUnionFT)</l>
<c></c>
<l>PixelAccuracyX:=0.0958926</l>
<l>PixelAccuracyY:=0.09402664</l>
<c>* 0.09419454</c>
<c>*0.09402664</c>
<c></c>
<c>* // 定义缩小比例</c>
<l>ScaleFactorX := 1</l>
<l>ScaleFactorY := PixelAccuracyY/(PixelAccuracyX+0.0000001)</l>
<c>* // 根据需要调整这个比例</c>
<l>zoom_region (RegionUnionFT, RegionUnionFTZoom, ScaleFactorX, ScaleFactorY)</l>
<c></c>
<c></c>
<c>***************************角度计算开始****************************************</c>
<l>smallest_rectangle2 (RegionUnionFTZoom, Row1, Column1, Phi1, Length11, Length21)</l>
<l>tuple_deg (Phi1, Deg)</l>
<l>tuple_sin(Phi1, Sin)</l>
<l>a:=20880*Sin</l>
<c></c>
<l>AngleRadiansH:=[]</l>
<l>tuple_abs(Phi1,AngleRadians1)</l>
<l>if(AngleRadians1&gt;0.785)</l>
<l>    AngleRadians2 :=3.1415926/2-AngleRadians1</l>
<l>    AngleRadiansH:=[AngleRadiansH,AngleRadians1]</l>
<l>    AngleRadiansH:=[AngleRadiansH,AngleRadians2]</l>
<c></c>
<l>  if(Phi1&gt;0 and AngleRadians1&gt;0.785)</l>
<c></c>
<l>    AngleRadians:=min(AngleRadiansH)</l>
<l>  else</l>
<l>    AngleRadians:=-min(AngleRadiansH)</l>
<l>  endif</l>
<l>else</l>
<l>  if(Phi1&gt;0)</l>
<l>    AngleRadians:=-Phi1</l>
<l>  else</l>
<l>    AngleRadians:=AngleRadians1</l>
<l>  endif</l>
<l>endif</l>
<c>*************************************角度计算结束********************************************</c>
<c>* 创建仿射变换矩阵 </c>
<l>hom_mat2d_identity(HomMat2D) </l>
<c></c>
<l>hom_mat2d_rotate(HomMat2D, AngleRadians, 0, 0, HomMat2DRotated) </l>
<c></c>
<c>* 应用仿射变换 </c>
<l>affine_trans_region(RegionUnionFTZoom, TransformedRegion, HomMat2DRotated, 'nearest_neighbor')</l>
<c>*******缩小展示开始**********************************</c>
<l>if(Width&lt;Height)</l>
<l>hom_mat2d_rotate(HomMat2D, AngleRadians+3.1415926/2, 0, 0, HomMat2DRotated1) </l>
<l>affine_trans_region(RegionUnionFTZoom, TransformedRegion1, HomMat2DRotated1, 'nearest_neighbor')</l>
<l>else</l>
<l>  TransformedRegion1:= TransformedRegion</l>
<l>endif</l>
<l>zoom_region (TransformedRegion1, RegionZoom, 0.1, 0.1)</l>
<l>area_center (RegionZoom, Area, Row, Column)</l>
<l>region_features (RegionZoom, 'width', ValueW)</l>
<l>region_features (RegionZoom, 'height', ValueH)</l>
<l>RowMove:=((ValueH+400)/2-Row)</l>
<l>ColumMove:=((ValueW+600)/2-Column)</l>
<l>move_region (RegionZoom, RegionMoved, RowMove, ColumMove)</l>
<l>dilation_circle (RegionMoved, RegionDilation, 1.5)</l>
<l>region_to_bin (RegionDilation, OutLineImage, 255, 0, ValueW+600, ValueH+400)</l>
<c>*******缩小展示结束**********************************</c>
<c>*图2旋转</c>
<l>affine_trans_image (Image2, ImageAffineTrans, HomMat2DRotated, 'constant', 'false')</l>
<c></c>
<c>***玻璃轮廓填充************</c>
<l>opening_circle (TransformedRegion, TransformedRegionOpening, 30.5)</l>
<l>closing_rectangle1 (TransformedRegionOpening, RegionClosingFT, 1, 1000)</l>
<l>closing_rectangle1 (RegionClosingFT, RegionFilled, 1000, 1)</l>
<c>***缺口提取**************</c>
<l>difference (RegionFilled, TransformedRegion, RegionDifferenceQK)</l>
<l>opening_circle (RegionDifferenceQK, RegionOpeningQK, 10.5)</l>
<l>connection (RegionOpeningQK, ConnectedRegionsQK)</l>
<l>select_shape (ConnectedRegionsQK, SelectedRegionsQK, 'area', 'and', 1000, 999999999)</l>
<c>***外围轮廓提取**************</c>
<l>difference (RegionFilled, SelectedRegionsQK, RegionContour)</l>
<l>opening_circle (RegionContour, RegionContour, 3.5)</l>
<l>GlassOutline:=RegionContour</l>
<c></c>
<l>gen_contour_region_xld (RegionFilled, Contours, 'border')</l>
<l>segment_contours_xld (Contours, ContoursSplit, 'lines_circles', 5, 4, 2)</l>
<l>union_collinear_contours_xld (ContoursSplit, UnionContours, 10, 1, 10, 0.5, 'attr_keep')</l>
<l>elliptic_axis_xld (UnionContours, Ra, Rb, Phi)</l>
<l>fit_line_contour_xld (UnionContours, 'tukey', -1, 0, 5, 2, RowBegin, ColBegin, RowEnd, ColEnd, Nr, Nc, Dist)</l>
<l>gen_region_line (RegionLines, RowBegin, ColBegin, RowEnd,ColEnd)  </l>
<c>   *水平线</c>
<l>   select_shape (RegionLines, RegionLinesV, 'width', 'and', 0.5*RegionsWidth, 999999999)  </l>
<l>   count_obj (RegionLinesV, NumberV)</l>
<l>if(NumberV&gt;0) </l>
<l>   region_features (RegionLinesV, 'orientation', ValueOriV)</l>
<l>   c:=((ValueOriV[&gt;]3.1 and ValueOriV[&lt;]3.17) or (ValueOriV[&lt;]0.05 and ValueOriV[&gt;]-0.03))</l>
<l>   d:=find(c,1)</l>
<l>   if(d!=-1)</l>
<l>     select_obj (RegionLinesV, RegionLinesVSelected, d+1)</l>
<l>     gen_contour_region_xld (RegionLinesVSelected, LinesVContours, 'border') </l>
<l>     count_obj (LinesVContours, NumberVContours)</l>
<l>     gen_empty_obj (Contours11X)</l>
<l>     gen_empty_obj (Contours12X)</l>
<l>       if(NumberVContours&gt;1)</l>
<l>            area_center_xld (LinesVContours, Area2, Row2, Column2, PointOrder)</l>
<l>            tuple_sort_index (Area2, Indices)  </l>
<l>            tuple_inverse (Indices, Inverted)</l>
<l>            tuple_select (Inverted, 0, aa)</l>
<l>            tuple_select (Inverted, 1, bb)</l>
<l>            select_obj (LinesVContours, Contours11X, aa+1)</l>
<l>            select_obj (LinesVContours, Contours12X, bb+1)</l>
<l>       endif</l>
<c>       </c>
<l>             elliptic_axis_xld (Contours11X, Ra1, Rb1, Phi11) </l>
<l>             elliptic_axis_xld (Contours12X, Ra1, Rb1, Phi12)</l>
<l>             tuple_deg (Phi11, Deg11)</l>
<l>             tuple_deg (Phi12, Deg12)</l>
<l>             avg_phi:=(Phi11+Phi12)/2</l>
<l>             avg_deg:=(Deg11+Deg12)/2</l>
<c>             </c>
<l>             tuple_cos (-avg_phi, Cos)</l>
<c>             </c>
<c>             </c>
<l>        distance_cc_min (Contours11X, Contours12X, 'fast_point_to_segment', DistanceHMin)</l>
<l>        GlassHeight:=DistanceHMin*pixValue</l>
<l>   endif</l>
<l>endif</l>
<c>   *竖线</c>
<l>   select_shape (RegionLines, RegionLinesHSelected, 'ra', 'and', 500, 9999999999)</l>
<l>   count_obj (RegionLinesHSelected, NumberH)</l>
<l>if(NumberH&gt;0)    </l>
<l>   region_features (RegionLinesHSelected, 'orientation', ValueOriH)</l>
<l>   c:=((ValueOriH[&gt;]1.54 and ValueOriH[&lt;]1.6) or (ValueOriH[&lt;]-1.54 and ValueOriH[&gt;]-1.6))</l>
<l>   d:=find(c,1)</l>
<l>   if(d!=-1)</l>
<l>        select_obj (RegionLinesHSelected, RegionLinesHSelected, d+1)</l>
<l>        gen_contour_region_xld (RegionLinesHSelected, LinesHContours, 'border')  </l>
<l>        count_obj (LinesHContours, NumberHContours)</l>
<l>        gen_empty_obj (Contours11Y)</l>
<l>        gen_empty_obj (Contours12Y)</l>
<l>            if(NumberHContours&gt;1)</l>
<l>                area_center_xld (LinesHContours, Area2, Row2, Column2, PointOrder)</l>
<l>                tuple_sort_index (Area2, Indices)  </l>
<l>                tuple_inverse (Indices, Inverted)</l>
<l>                tuple_select (Inverted, 0, aa)</l>
<l>                tuple_select (Inverted, 1, bb)</l>
<l>                select_obj (LinesHContours, Contours11Y, aa+1)</l>
<l>                select_obj (LinesHContours, Contours12Y, bb+1)</l>
<l>            endif</l>
<l>        distance_cc_min (Contours11Y, Contours12Y, 'point_to_point', DistanceWMin)</l>
<l>        GlassWidth:=DistanceWMin*pixValue</l>
<l>   endif</l>
<l>endif</l>
<c></c>
<c>****测量标准***************************************</c>
<l>GlassCriterionW:=10</l>
<l>GlassCriterionH:=10</l>
<l>GlassErrRange:=1</l>
<l>GlassOK:='OK'</l>
<c>****测量标准***************************************</c>
<c></c>
<l>region_features (SelectedRegionsQK, 'roundness', RegionsRoundness)</l>
<l>c:=(RegionsRoundness[&gt;]0.9)</l>
<l>d:=find(c,1)</l>
<l>if(d!=-1)</l>
<l>select_obj (SelectedRegionsQK, SelectedRegionsHoles, d+1)</l>
<l>count_obj (SelectedRegionsHoles, Number2)</l>
<l>tuple_gen_const (Number2, '孔', HolesTuple)</l>
<c> </c>
<l>difference (SelectedRegionsQK, SelectedRegionsHoles, RegionDifference)</l>
<l>connection (RegionDifference, SelectedRegionsMJ)</l>
<l>select_shape (SelectedRegionsMJ, SelectedRegionsMJ, 'area', 'and', 1000, 999999)</l>
<l>count_obj (SelectedRegionsMJ, Number3)</l>
<l>tuple_gen_const (Number3, '门夹', MenJiaTuple)</l>
<l>tuple_concat (HolesTuple, MenJiaTuple, Type)</l>
<c></c>
<l>concat_obj (SelectedRegionsHoles, SelectedRegionsMJ, ObjectsConcatQK)</l>
<l>endif</l>
<c></c>
<l>count_obj (ObjectsConcatQK, Number1)</l>
<l>if(Number1&gt;0)  </l>
<l>smallest_rectangle1 (ObjectsConcatQK, Row11, Column11, Row12, Column12)</l>
<l>gen_rectangle1 (Rectangle, Row11-50, Column11/ScaleFactorX-50, Row12+50, Column12/ScaleFactorX+50)</l>
<l>  for Index2 := 1 to Number1 by 1</l>
<l>    select_obj (Rectangle, ObjectSelected, Index2)</l>
<l>    reduce_domain (ImageAffineTrans, ObjectSelected, ImageReduced)</l>
<l>    crop_domain (ImageReduced, ImagePart)</l>
<l>    concat_obj (QKImage, ImagePart, QKImage)</l>
<l>  endfor</l>
<c></c>
<c>*****</c>
<l>area_center (ObjectsConcatQK, AreaQK, RowQK, ColumnQK)</l>
<l>region_features (SelectedRegionsHoles, 'width', width_Holes)</l>
<l>region_features (SelectedRegionsHoles, 'height', height_Holes)</l>
<l>QKWidth:=width_Holes*pixValue</l>
<l>QKHeight:=height_Holes*pixValue</l>
<c></c>
<c></c>
<l>region_features (SelectedRegionsMJ, 'width', width_MJ)</l>
<l>region_features (SelectedRegionsMJ, 'height', height_MJ)</l>
<l>QKWidth:=[QKWidth,width_MJ*pixValue]</l>
<l>QKHeight:=[QKHeight,height_MJ*pixValue]</l>
<c></c>
<c>**水平方向距离</c>
<l>dis_min1:=[]</l>
<l>dis_min2:=[]</l>
<l>distance_pc (Contours11X, RowQK, ColumnQK, DistanceMin1, DistanceMax1)</l>
<l>distance_pc (Contours12X, RowQK, ColumnQK, DistanceMin2, DistanceMax2)</l>
<l>dis_min1:= DistanceMin1</l>
<l>dis_min2:= DistanceMin2</l>
<l>count:=|dis_min1|</l>
<l>dismin_horn:=[]</l>
<l>for Index1 := 1 to count by 1</l>
<l>    tuple_select (dis_min1, Index1-1, Selected1)</l>
<l>    tuple_select (dis_min2, Index1-1, Selected2)    </l>
<l>    tuple_min2 (Selected1, Selected2, Min2) </l>
<l>    dismin_horn:=[dismin_horn,Min2]</l>
<l>endfor</l>
<l>DistanceHorizontal:=dismin_horn*pixValue</l>
<c>***dismin_horn水平距离结果</c>
<c></c>
<c>**垂直方向距离</c>
<l>dis_min1:=[]</l>
<l>dis_min2:=[]</l>
<l>distance_pc (Contours11Y, RowQK, ColumnQK, DistanceMin1, DistanceMax1)</l>
<l>distance_pc (Contours12Y, RowQK, ColumnQK, DistanceMin2, DistanceMax2)</l>
<l>dis_min1:= DistanceMin1</l>
<l>dis_min2:= DistanceMin2</l>
<l>count:=|dis_min1|</l>
<l>dismin_ver:=[]</l>
<c></c>
<l>for Index1 := 1 to count by 1</l>
<l>    tuple_select (dis_min1, Index1-1, Selected1)</l>
<l>    tuple_select (dis_min2, Index1-1, Selected2)  </l>
<l>    tuple_min2 (Selected1, Selected2, Min2)</l>
<l>    dismin_ver:=[dismin_ver,Min2]  </l>
<l>endfor</l>
<l>DistanceVertical:=dismin_ver*pixValue</l>
<l>endif</l>
<c></c>
<l>CriterionX:=10</l>
<l>CriterionY:=10</l>
<l>CriterionW:=10</l>
<l>CriterionH:=10</l>
<l>ErrRange:=1</l>
<l>for Index3 := 1 to Number1 by 1</l>
<l>    QKOK:=[QKOK,'OK']</l>
<l>endfor</l>
<c>*****dismin_ver垂直距离</c>
<c></c>
<c>*****************************************************************************************************</c>
<c>*************************收集数据******************************* </c>
<l>create_dict (ResultDictHoles)</l>
<l>set_dict_tuple (ResultDictHoles, 'GlassOK', GlassOK)</l>
<l>set_dict_tuple (ResultDictHoles, 'GlassHeight', GlassHeight)</l>
<l>set_dict_tuple (ResultDictHoles, 'GlassWidth', GlassWidth)</l>
<l>set_dict_tuple (ResultDictHoles, 'Type', Type)</l>
<l>set_dict_tuple (ResultDictHoles, 'QKOK', QKOK)</l>
<l>set_dict_tuple (ResultDictHoles, 'DistanceHorizontal', DistanceHorizontal)</l>
<l>set_dict_tuple (ResultDictHoles, 'DistanceVertical', DistanceVertical)</l>
<l>set_dict_tuple (ResultDictHoles, 'QKWidth', QKWidth)</l>
<l>set_dict_tuple (ResultDictHoles, 'QKHeight', QKHeight)</l>
<c></c>
<c></c>
<l>return ()</l>
<l>catch (Exception)</l>
<c>   </c>
<l>endtry</l>
</body>
<docu id="ProcessHoles">
<parameters>
<parameter id="DetectDict"/>
<parameter id="HolesImage"/>
<parameter id="Image1"/>
<parameter id="Image2"/>
<parameter id="Image3"/>
<parameter id="OutLineImage"/>
<parameter id="ResultDictHoles"/>
</parameters>
</docu>
</procedure>
</hdevelop>
